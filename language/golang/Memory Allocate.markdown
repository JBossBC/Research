# Memory allocate

golang将内存分成了大大小小67个级别的span,其中,0级代表特殊的大对象，其大小是不固定的。**当具体的对象需要分配内存时，并不是直接分配span,而是分配不同级别的span中的元素**。因此span的级别不是以每个span的大小为依据的，而是以span中元素的大小为依据的。



## 概述

基本策略:

1. 每次从操作系统申请一大块内存(比如1MB),以减少系统调用。
2. 将申请到的大块内存按照特定大小预先切分成小块，构成链表。
3. 为对象分配内存时，只需从大小合适的链表提取一个小块即可。
4. 回收对象内存时，将该小块内存重新归还到原链表，以便复用。
5. 如闲置内存过多，则尝试归还部分内存给操作系统，降低整体开销。

> 内存分配器只管理内存块，并不关心对象状态。且不会主动回收内存，由垃圾回收器在完成清理操作后，触发内存分配器回收操作。


### 内存块

分配器将其管理的内存块分为两种:

+ span:由多个地址连续的页(page)组成的大块内存。
+ object:将span按特定大小切分成多个小块，每个小块可存储一个对象

> 按照其用途，span面向内部管理，object面向对象分配。

分配器按页数来区分不同大小的span，比如，以页数为单位将span存放到管理数组中，需要时就以页数为索引进行查找。当然，span大小并非固定不变。在获取闲置span时，如果没找到大小合适的，那就返回页数更多的，此时会引发裁剪操作，多余部分将构成新的span被放回管理数组。分配器还会尝试将地址相邻的空闲span合并，以构建更大的内存块，减少碎片，提供更灵活的分配策略。

用于存储对象的object，按8字节倍数分为n种。比如说，大小为24的object可用来存储范围在17·24字节的对象。这种方式虽然会造成一些内存浪费，但分配器只需面对有限的几种规格小块内存，优化了分配和复用管理策略。

> 分配器会尝试将多个微笑对象组合到一个object块内，以节约内存

分配器初始化时，会构建对照表存储大小和规格得对应关系，包括用来切分的span页数。

若对象大小超过特定阈值限制，会被当作大对象特别对待。

### 管理组件

优秀的内存分配器必须要在性能和内存利用率之间做到平衡。好在，Golang的起点很高，直接采用了tcmalloc的成熟架构。每个逻辑处理器P都存储了一个本地span缓存，称为mcache。如果协程需要内存可以直接从mcache中获取，**由于在同一时间只有一个协程运行在逻辑处理器p上，所以中间不需要加锁。**mcache包含所有大小规格的mspan,但是每种规格大小只包含一个。除class0外，mcache的span都来自mcentral。

  

分配器由三种组件组成。

+ cache:每个运行期工作线程都会绑定一个cache，用于无锁object分配。
+ central:为所有cache提供切分好的后备span资源。
+ heap:管理闲置span，需要时向操作系统申请新内存。
   + mcentral是被所有逻辑处理器P共享的
   + mcentral对象收集所有给定规格大小的span。每个mcentraal都包含两个mspan的链表:empty mspanList表示没有空闲对象或**span已经被mcache缓存的span链表**,nonempty mspanList表示有空闲对象的span链表。


分配流程:

1. 计算待分配对象相应规格。
2. 从cache.alloc数组找到规格相同的span。
3. 从span.freelist链表提取可用object。
4. 如span.freelist为空，从1central获取新的span。
5. 如central.nonempty为空，从heap.free/freelarge获取，并切分成object链表。
6. 如heap没有大小合适的闲置span，向操作系统申请新内存块

释放流程:

1. 将标记为可回收object交还给所属的span.freelist。
2. 该span被放回central，可供任意cache重新获取使用
3. 如span已回收全部object，则将其交还给heap，以便重新切分复用
4. 定期扫描heap里长时间闲置的span，释放其占用内存。

注:以上不包括大对象，它直接从heap分配和回收

作为工作线程私有且不被共享的cache是实现高性能无锁分配的核心，而central的作用是在多个cache间提高object利用率，避免内存浪费。

     假设cache1获取一个span后，仅使用了一部分object，那么剩余空间就会被浪费，而回收操作将该span交还给central后，该span完全可以被cache2、cacheN获取使用。此时，cache1已不再持有该span，完全不会造成问题。

将span归还给heap，是为了在不同规格object需求间平衡

     某时段某种规格的object需求量可能激增，那么当需求过后，大量被切分成该规格的span就会被闲置浪费。将归还给heap，就可被其他需求获取，重新切分。

### 初始化

因为内存分配器和垃圾回收算法都依赖连续地址，所以在初始化阶段，预先保留了很大的一段虚拟地址空间。

**注意:保留地址空间，并不会分配内存**
