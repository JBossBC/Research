# Memory allocate


## 概述

基本策略:

1. 每次从操作系统申请一大块内存(比如1MB),以减少系统调用。
2. 将申请到的大块内存按照特定大小预先切分成小块，构成链表。
3. 为对象分配内存时，只需从大小合适的链表提取一个小块即可。
4. 回收对象内存时，将该小块内存重新归还到原链表，以便复用。
5. 如闲置内存过多，则尝试归还部分内存给操作系统，降低整体开销。

> 内存分配器只管理内存块，并不关心对象状态。且不会主动回收内存，由垃圾回收器在完成清理操作后，触发内存分配器回收操作。


### 内存块

分配器将其管理的内存块分为两种:

+ span:由多个地址连续的页(page)组成的大块内存。
+ object:将span按特定大小切分成多个小块，每个小块可存储一个对象

> 按照其用途，span面向内部管理，object面向对象分配。

分配器按页数来区分不同大小的span，比如，以页数为单位将span存放到管理数组中，需要时就以页数为索引进行查找。当然，span大小并非固定不变。在获取闲置span时，如果没找到大小合适的，那就返回页数更多的，此时会引发裁剪操作，多余部分将构成新的span被放回管理数组。分配器还会尝试将地址相邻的空闲span合并，以构建更大的内存块，减少碎片，提供更灵活的分配策略。

用于存储对象的object，按8字节倍数分为n种。比如说，大小为24的object可用来存储范围在17·24字节的对象。这种方式虽然会造成一些内存浪费，但分配器只需面对有限的几种规格小块内存，优化了分配和复用管理策略。

> 分配器会尝试将多个微笑对象组合到一个object块内，以节约内存

分配器初始化时，会构建对照表存储大小和规格得对应关系，包括用来切分的span页数。

若对象大小超过特定阈值限制，会被当作大对象特别对待。

### 管理组件

优秀的内存分配器必须要在性能和内存利用率之间做到平衡。好在，Golang的起点很高，直接采用了tcmalloc的成熟架构。

分配器由三种组件组成。

+ cache:每个运行期工作线程都会绑定一个cache，用于无锁object分配。
+ central:为所有cache提供切分好的后备span资源。
+ heap:管理闲置span，需要时向操作系统申请新内存。

分配流程:

1. 计算待分配对象相应规格。
2. 从cache.alloc数组找到规格相同的span。
3. 从span.freelist链表提取可用object。
4. 如span.freelist为空，从1central获取新的span。
5. 如central.nonempty为空，从heap.free/freelarge获取，并切分成object链表。
6. 如heap没有大小合适的闲置span，向操作系统申请新内存块

释放流程:

1. 将标记为可回收object交还给所属的span.freelist。
2. 该span被放回central，可供任意cache重新获取使用
3. 如span已回收全部object，则将其交还给heap，以便重新切分复用
4. 定期扫描heap里长时间闲置的span，释放其占用内存。