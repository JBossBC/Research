# Memory allocate

golang将内存分成了大大小小67个级别的span,其中,0级代表特殊的大对象，其大小是不固定的。**当具体的对象需要分配内存时，并不是直接分配span,而是分配不同级别的span中的元素**。因此span的级别不是以每个span的大小为依据的，而是以span中元素的大小为依据的。



## 概述

基本策略:

1. 每次从操作系统申请一大块内存(比如1MB),以减少系统调用。
2. 将申请到的大块内存按照特定大小预先切分成小块，构成链表。
3. 为对象分配内存时，只需从大小合适的链表提取一个小块即可。
4. 回收对象内存时，将该小块内存重新归还到原链表，以便复用。
5. 如闲置内存过多，则尝试归还部分内存给操作系统，降低整体开销。

> 内存分配器只管理内存块，并不关心对象状态。且不会主动回收内存，由垃圾回收器在完成清理操作后，触发内存分配器回收操作。

## 对象分配
<<<<<<< HEAD
=======

不同大小的对象会分配到不同的span中，在运行时分配对象的逻辑主要位于mallocgc中，malloc代表分配，gc代表垃圾回收，此函数除了分配内存还会为垃圾回收做一些位图标记工作。

内存分配时,将对象按照大小不同划分为微小对象、小对象、大对象。微小对象的分配流程最长，逻辑链路最复杂。

+ 微小对象的内存分配

golang将小于16bytes的对象划分为微小对象。划分微小对象的主要目的是处理极小的字符串和独立的转义变量。对json的基准测试表明，使用微小对象减少了12%的分配次数和20%的堆大小。

微小对象首先会被放入class为2的span中。首先会对微小对象按照2、4、8的规则进行字节对齐。查看之前分配的元素中是否有空余的空间。如果当前对象要分配8字节，并且正在分配的元素可以容纳8字节，则返回tiny+offset，意味着当前地址往后8字节都是可以被分配的。

如果当前要分配的元素空间不够，将尝试从mcache中查找span中下一个可用得到元素。因此，tiny分配的第一步是尝试利用分配过的前一个元素的空间。

在查找空闲元素空间时,首先需要从mcache中找到对应级别的mspan,mspan中拥有allocCache字段，其作为一个位图，用于标记span中的元素是否被分配。由于allocCache元素为uint64,因此其最多一次缓存64个字节。

allocCache使用小端模式标记span中的元素是否被分配。allocCache中的最后1bit对应的是span中的第一个元素是否被分配(如果span超过64个大小，则还会加上freeindex偏移量）。当bit位为1时代表当前对应的span中的元素已经被分配。只要从allocCache开始找到哪一位为0即可，加入X为0,那么X+freeindex为当前span中可用的元素序号。当allocCache中所有bit位都标记为1时，需要移动freeindex并更新allocCache，一直到span中元素的末尾为止。


>>>>>>> 74eb18ba1aab694c2fa7c678f3db2a1c56196112

不同大小的对象会分配到不同的span中，在运行时分配对象的逻辑主要位于mallocgc中，malloc代表分配，gc代表垃圾回收，此函数除了分配内存还会为垃圾回收做一些位图标记工作。

内存分配时,将对象按照大小不同划分为微小对象、小对象、大对象。微小对象的分配流程最长，逻辑链路最复杂。

+ 微小对象的内存分配

golang将小于16bytes的对象划分为微小对象。划分微小对象的主要目的是处理极小的字符串和独立的转义变量。对json的基准测试表明，使用微小对象减少了12%的分配次数和20%的堆大小。

微小对象首先会被放入class为2的span中。首先会对微小对象按照2、4、8的规则进行字节对齐。查看之前分配的元素中是否有空余的空间。如果当前对象要分配8字节，并且正在分配的元素可以容纳8字节，则返回tiny+offset，意味着当前地址往后8字节都是可以被分配的。

如果当前要分配的元素空间不够，将尝试从mcache中查找span中下一个可用得到元素。因此，tiny分配的第一步是尝试利用分配过的前一个元素的空间。

在查找空闲元素空间时,首先需要从mcache中找到对应级别的mspan,mspan中拥有allocCache字段，其作为一个位图，用于标记span中的元素是否被分配。由于allocCache元素为uint64,因此其最多一次缓存64个字节。

allocCache使用小端模式标记span中的元素是否被分配。allocCache中的最后1bit对应的是span中的第一个元素是否被分配(如果span超过64个大小，则还会加上freeindex偏移量）。当bit位为1时代表当前对应的span中的元素已经被分配。只要从allocCache开始找到哪一位为0即可，加入X为0,那么X+freeindex为当前span中可用的元素序号。当allocCache中所有bit位都标记为1时，需要移动freeindex并更新allocCache，一直到span中元素的末尾为止。

+ mcentral遍历span

如果当前的span中没有可以使用的元素，这个时候就需要从mcentral中加锁查找(所有调度器P都共享一个mcentral。mcentral有两种类型的span链表，分别是有空闲元素的nonempty链表和没有空闲元素的empty链表。**在mcentral查找时，会分别遍历这两个链表，查找是否有可用的span。**

为什么还要遍历没有空闲元素的empty链表呢?因为golang采用并发时三色标记法进行垃圾回收，可能有些span虽然被垃圾回收器标记为空闲了，但是还没有来得及清理，这些span在清扫后是可以使用的，因此需要遍历...

如果在mcentral中查找到有空闲元素的span，则会将其赋值到mcache中，并更新allocCache，同时需要将span添加到mcentral的empty链表中去。

+ mheap缓存查找

如果在mcentral中找不到可以使用的span,就需要在mheap中查找。Go1.12采用treap结构进行内存管理,treap是一种引入了随机数的二叉搜索树，引入的随机数及必要时的旋转保证了比较好的平衡性(一定程度上消除了因为极致的)。
### 内存块

分配器将其管理的内存块分为两种:

+ span:由多个地址连续的页(page)组成的大块内存。
+ object:将span按特定大小切分成多个小块，每个小块可存储一个对象

> 按照其用途，span面向内部管理，object面向对象分配。

分配器按页数来区分不同大小的span，比如，以页数为单位将span存放到管理数组中，需要时就以页数为索引进行查找。当然，span大小并非固定不变。在获取闲置span时，如果没找到大小合适的，那就返回页数更多的，此时会引发裁剪操作，多余部分将构成新的span被放回管理数组。分配器还会尝试将地址相邻的空闲span合并，以构建更大的内存块，减少碎片，提供更灵活的分配策略。

用于存储对象的object，按8字节倍数分为n种。比如说，大小为24的object可用来存储范围在17·24字节的对象。这种方式虽然会造成一些内存浪费，但分配器只需面对有限的几种规格小块内存，优化了分配和复用管理策略。

> 分配器会尝试将多个微笑对象组合到一个object块内，以节约内存

分配器初始化时，会构建对照表存储大小和规格得对应关系，包括用来切分的span页数。

若对象大小超过特定阈值限制，会被当作大对象特别对待。

### 管理组件

优秀的内存分配器必须要在性能和内存利用率之间做到平衡。好在，Golang的起点很高，直接采用了tcmalloc的成熟架构。每个逻辑处理器P都存储了一个本地span缓存，称为mcache。如果协程需要内存可以直接从mcache中获取，**由于在同一时间只有一个协程运行在逻辑处理器p上，所以中间不需要加锁。**mcache包含所有大小规格的mspan,但是每种规格大小只包含一个。除class0外，mcache的span都来自mcentral。

  

分配器由三种组件组成。

+ cache:每个运行期工作线程都会绑定一个cache，用于无锁object分配。
+ central:为所有cache提供切分好的后备span资源。
+ heap:管理闲置span，需要时向操作系统申请新内存。
   + mcentral是被所有逻辑处理器P共享的
   + mcentral对象收集所有给定规格大小的span。每个mcentraal都包含两个mspan的链表:empty mspanList表示没有空闲对象或**span已经被mcache缓存的span链表**,nonempty mspanList表示有空闲对象的span链表。

mheap的作用不只是管理central，大对象也会直接通过mheap进行分配。mheap实现了对虚拟内存线性地址空间的精准管理，建立了span与具体线性地址空间的联系,保存了分配的位图信息，是管理内存的最核心单元。后面还会看到，堆区的内存被分成了HeapArea大小进行管理。对Heap进行的操作必须全局加锁，而mcache、mcentral可以被看作某种形式的缓存。

分配流程:

1. 计算待分配对象相应规格。
2. 从cache.alloc数组找到规格相同的span。
3. 从span.freelist链表提取可用object。
4. 如span.freelist为空，从central获取新的span。
5. 如central.nonempty为空，从heap.free/freelarge获取，并切分成object链表。
6. 如heap没有大小合适的闲置span，向操作系统申请新内存块

释放流程:

1. 将标记为可回收object交还给所属的span.freelist。
2. 该span被放回central，可供任意cache重新获取使用
3. 如span已回收全部object，则将其交还给heap，以便重新切分复用
4. 定期扫描heap里长时间闲置的span，释放其占用内存。

注:以上不包括大对象，它直接从heap分配和回收

作为工作线程私有且不被共享的cache是实现高性能无锁分配的核心，而central的作用是在多个cache间提高object利用率，避免内存浪费。

     假设cache1获取一个span后，仅使用了一部分object，那么剩余空间就会被浪费，而回收操作将该span交还给central后，该span完全可以被cache2、cacheN获取使用。此时，cache1已不再持有该span，完全不会造成问题。

将span归还给heap，是为了在不同规格object需求间平衡

     某时段某种规格的object需求量可能激增，那么当需求过后，大量被切分成该规格的span就会被闲置浪费。将归还给heap，就可被其他需求获取，重新切分。

### 初始化

因为内存分配器和垃圾回收算法都依赖连续地址，所以在初始化阶段，预先保留了很大的一段虚拟地址空间。

**注意:保留地址空间，并不会分配内存**
