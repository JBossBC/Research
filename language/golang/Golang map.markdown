# Golang map


## Question

为什么溢出桶过多会导致内存泄露

什么是内存泄露

----

go语言中的map又被称为哈希表，是使用频率极高的一种数据结构。哈希表的原理是将多个键/值对分散存储在buckets(桶)中。

    hash=hashfunc(key)
    index=hash%array_size

在此伪代码中,第一部通过哈希算法计算键的哈希值，其结果与桶的数量无关。接着通过执行模运算得到0-array_size-1之间的index序号。在实践中，我们通常将map看作O(1)时间复杂度的操作，通过一个键(key)快速寻找对应的唯一值(value)。在许多情况下,哈希表的查找速度明显快于一些搜索树形式的数据结构，被广泛用于关联数组、缓存、数据库缓存等场景中。

## 哈希碰撞和解决方法

哈希函数在实际中遇到的最常见的问题是哈希碰撞，即不同的键通过哈希函数可能产生相同的哈希值。如果将2450个键随机分配到一百万个桶中，根据概率计算，至少有两个键被分配到同一个桶中的可能性有95%，it's crazy。哈希碰撞导致一个桶中可能存在多个元素，有多种方式可以避免哈希碰撞,一般有两种方法:**拉链法以及开放寻址法**

拉链法将同一个桶中的元素通过链表的形式进行连接，这是一种最简单、最常用的策略。随着桶中元素的增加，可以不断连接新的元素，同时不用预先为元素分配内存。**拉链法的不足之处在于,需要存储额外的指针用于链接元素,这增加了整个哈希表的大小。同时由于链表存储的地址不连续,所以无法高效利用CPU高速缓存(amazing),同时我们也应该注意到,利用CPU高速缓存的同时，也需要注意缓存一致性可能导致的性能损失。**

与拉链法对应的另一种解决哈希碰撞的策略为开放寻址法。所有元素都存储在桶的数组中，当必须插入新条目时，将按某种探测策略操作，直到找到未使用的数组插槽为止。当搜索元素时,将按相同顺序扫描存储桶,直到查找到目标记录或找到未使用的插槽为止。


Go语言中的哈希表采用的是优化的拉链法,每一个桶中存储了8个元素用于加速访问。虽然对值为nil的map进行访问结果毫无意义，但go语言允许这种操作

对map进行访问的时候,可以返回两个参数,第二个参数代表当前key在map中是否存在。

delete时Go语言中的关键字,用于进行map的删除操作,可以对相同的key进行多次删除操作而不会报错

### key的比较性

+ 布尔值是可以比较的
+ 整数值是可以比较的
+ 浮点值是可以比较的
+ 复数值是可以比较的
+ 字符串值是可以比较的
+ 指针值是可以比较的。如果两个指针值指向相同的变量，或者两个指针的值均为nil,则他们相等
+ 通道值是可比较的。如果两个通道值是由相同的make函数调用创建的，或者两个值都为nil,则它们相等
+ 接口值是可以比较的。如果两个接口值具有相同的动态类型和相同的动态值，或者两个接口值都是nil,则它们相等
+ 如果结构的所有字段是可以比较的，则它们的值是可以比较的
+ 如果数组元素类型的值是可以比较的，则数组值可比较。如果两个数组对应的元素相等，则它们相等
+ 切片、函数、map是不可比较的

### map并发冲突

和其他语言不同的是,map并不支持并发的读写，map的并发读写是初级开发者经常会犯的错误。
Go语言只支持并发读取map

Go不支持并发读写的原因:map不需要从多个Goroutine安全访问，在实际情况下，map可能是某些已经同步的较大数据结构或计算的一部分。因此,要求所有map操作都互斥将减慢大多数程序的速度，只会增加少数程序的安全性，**Go只支持并发读取的原因是保证大多数场景下的查找效率**。

### 哈希表的底层结构

Go map的底层实现
    
     type hmap struct{
          count int
          flags uint8
          B uint8
          noverflow uint16
          hash0 uint32
          buckets unsafe.Pointer
          oldbuckets unsafe.Pointer
          nevacuate uintptr
          extra *mapextra
    }

+ count代表map中元素的数量
+ flags代表当前map的状态(是否处于正在写入的状态等)
+ 2的B此幂代表当前map中桶的数量,2^B=Buckets size
+ noverflow为map中溢出桶的数量。当溢出桶太多时,map会进行same-size map growth,其实质是避免溢出桶过大导致内存泄露
+ hash0代表生成hash的随机数种子
+ buckets是指向当前map对应的桶的指针
+ oldbuckets是在map扩容时存储旧桶的，当所有旧桶中的数据都已经转移到了新桶时，则清空
+ nevacuate 在扩容时使用，用于标记当前旧桶中小于nevacuate的数据都已经转移到了新桶中
+ extra存储map中溢出的桶

代表桶的bmap结构在运行时只列出勒首个字段，即一个固定长度为8的数组。此字段顺序存储key的哈希值前8位**(一个桶只能存放8对k/v, 低8位用来寻找桶，高8位用来寻找元素)**

    type bmap struct{
      tophash [bucketCnt]uint8
    }
    

map在编译时即确定了map中的key、value以及桶的大小，因此运行时仅仅通过指针操作就可以找到特定位置的元素。


Go语言选择将key与value分开存储而不是以key/value/key/value的形式存储,是为了在字节对齐时压缩空间，这很好理解，也是为什么桶中的key/value是八对的部分原因

在进行map访问操作时,会首先找到桶的位置,找到桶的位置后遍历tophash数组,如果在数组中找到了相同的hash,那么可以**接着通过指针的寻址操作找到对应的key和value**

在Go语言中还有一个溢出桶的概念，在执行hash[key]=value赋值操作时,当指定桶中的数据超过8时,并不会直接开辟一个新桶，而是将数据放置到溢出桶中,每个桶的最后都存储了overflow,即溢出桶的指针。在正常情况下，数据是很少会跑到溢出桶里面去的

在执行查找操作时,如果key的hash在指定桶的tophash中不存在,那么需要遍历溢出桶中的数据

如果一开始,初始化map的数量比较大,则map会提前创建好一些溢出桶存储在extra *mapextra字段

    type mapextra struct{
     overflow *[]*bmap
     oldoverflow  *[]*bmap
     nextOverflow *bmap
    }

当出现溢出现象时,可以用提前创建好的桶而不用申请额外的内存空间。只有预分配的溢出桶使用完了,才会新建溢出桶

当发生以下两种情况之一时,map会进行重建(这两种情况总结为局部和整体的效率优化):

+ map超过了负载因子的大小
+ 溢出桶的数量过多

在哈希表中有经典的负载因子的概念

负载因子=哈希表中的元素数量/桶的数量

负载因子增大，意味着更多的元素会被分配到同一桶中，此时效率会减慢(逐步退化为线性效率)。Go语言中的负载因子为6.5，当超过其大小后,map会进行扩容,增大到旧表2倍的大小，旧桶的数据会存在oldbuckets字段中，并想办法分散转移到新桶中。

当旧桶中的数据全部转移到新桶中后，旧桶就会被清空。

当溢出桶的数量太多，这时map只会新建和原来相同大小的桶，目的是防止溢出桶的数量缓慢增长导致的内存泄露


### map初始化(make)

通过make初始化map的时候会检查len是否为整数，是否超过int的长度。同时会计算需要的桶的数量，log2N,并生成桶和溢出桶。如果初始化时生成了溢出桶，则会放置到map中的extra字段中。(只有当map的数量大于24,才会在初始化时生成溢出桶。溢出桶的大小为2(b-4),其中,b为桶的大小)





