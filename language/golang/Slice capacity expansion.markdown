# Slice expanse capacity

slice这种数据结构便于使用和管理数据集合，可以理解为是一种动态数组，slice也是围绕动态数组的概念来构建的。既然是动态数组，那么slice是如何扩容的呢？

+ 如果切片的容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2;一旦元素个数超过1024个元素，增长因子就变成1.25,即每次增加原来容量的四分之一
+ 如果扩容之后，还没有触及原数组的容量，那么切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组

切片的动态增长是通过内置函数append来实现的，这个函数可以快速高效的增长切片，还可以通过对切片再次切片来缩小一个切片的大小。切片是一个非常小的对象，它是对底层的数组进行了抽象，并且提供了相关的操作方法。他拥有三个字段，分别为:指向底层数组的指针，长度，容量。


## 具体分析(结合源码)

源码位置:runtime/slice.go growslice

注:我们将扩容后的实际容量表示为newCap,根据append()的传入参数得到的需要的目标容量表示为cap,原切片表示为oldSlice,扩容后的切片表示为newSlice,切片中元素类型表示为et

1. slice结合golang内置方法append进行动态扩容,具体实现方法为>
       `func growslice(et *_type, old slice, cap int) slice;`
         
        传入的参数分别为切片中元素的类型，原来的切片，目标切片的容量
2. golang首先会对目标容量进行判断，如果cap大于原来cap(oldSlice)的两倍，那么newCap就直接等于cap。
3. 对于cap小于或等于原来cap(oldSlice)的两倍，会有两种处理方式，①、当cap(oldSlice)小于1024的时候,newCap会直接等于cap(oldSlice)的两倍②、当cap(oldSlice)大于或等于1024的时候，会**循环增加newCap的四分之一直到newCap大于或等于cap**的时候,才停止循环
4. **golang并不会完全把上面计算的newCap当作最终的newCap，而是要根据**他的内存分配策略进行细微调整,从总的来说就是golang的内存对齐，我们接着下面来看。 

     + golang将这个策略结合切片中元素类型et具体细分为四种策略，但是核心理念就是需要将分配的内存进行对齐，具体实现为roundupSize方法
     + golang先判断从上面计算出来的size=newCap*unsafe.size(et)的大小，是否为小对象，如果是小对象，则根据golang内存分配进行内存补齐，也就是说，打个比方，如果上面计算出来的size为60，那么根据内存补齐，他会变成64来进行分配。
    


