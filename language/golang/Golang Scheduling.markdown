# Golang scheduling

## question

线程本地存储???存储在哪

-----

golang为了对协程进行更有效的管理，将协程分为多个状态

+ _Gidle为协程刚开始创建时的状态，当新创建的协程初始化后，会变为_Gdead状态,_Gdead状态也是写成被销毁时的状态
+ _Grunnable表示当前协程在运行队列中，正在等待运行
+ _Grunning代表当前协程正在被运行，已经被分配给了逻辑处理器和线程
+ _Gwaiting代表当前协程在运行时被锁定，不能执行用户代码。在垃圾回收及channel通信时会遇到这种情况
+ _Gsyscall代表当前协程正在执行系统调用
+ _Gpreempted是GO1.14新加的状态，代表协程G被强制抢占后的状态
+ _Gcopystack代表在进行协程栈扫描时发现需要扩容或缩小协程栈空间，将协程中的栈转移到新栈时的状态。


## 特殊协程g0与协程切换

协程g0运行在操作系统线程栈上，其主要作用是执行协程调度得一系列运行时代码，而一般的协程无差别地用于执行用户代码。很显然，执行用户代码的任何协程都不适合进行全局调度。

在用户协程退出或者被抢占时，意味着需要重新执行协程调度，这时需要从用户协程g切换到协程g0.要注意的是，每个线程地内部都在完成这样的切换与调度循环。

和线程类似，协程切换的过程叫做协程地上下文切换。当某一个协程g执行上下文切换时需要保存当前协程的执行现场，才能够在后面切换回g协程时正常执行。**协程的执行现场存储在g.gobuf结构体中，g.gobuf结构体主要保存CPU中几个重要的寄存器值，分别是rsp、rip、rbp。**

rsp寄存器始终指向函数调用栈栈顶，rip寄存器指向程序要执行的下一条指令，rbp存储了函数栈帧的起始位置。

特殊的协程g0与执行用户代码的协程g有明显不同，g0作为特殊的调度协程，其执行的函数和流程相对固定，并且为了避免栈溢出，协程g0的栈会重复使用。而每个执行用户代码的协程，可能都有不同的执行流程。每次上下文切换回去后，会继续执行之前的流程。

## 线程本地存储与线程绑定

线程本地存储是一种计算机编程方法，它使用线程本地的静态或者全局内存。和普通的全局变量对程序中的所有线程可见不同，线程本地存储中的变量只对当前线程可见。因此，这种类型的变量可以看作是线程"私有"的。一般地，操作系统使用FS/GS段寄存器存储线程本地变量。

在GO语言中，并没有直接暴露线程本地存储的编程方式,但是go语言运行时的调度器使用线程本地存储将具体操作系统的线程与运行时的代表线程的m结构体绑定在一起。如下所示，线程本地存储的实际是结构体m中m.tls地址，同时m.tls[0]会存储当前线程正在运行的协程g的地址，因此在任意一个线程内部，通过线程本地存储，都可以在任意时刻获取绑定到当前线程上的协程g、结构体m、逻辑处理器p、特殊协程g0等信息。