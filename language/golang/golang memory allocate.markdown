# Golang memory allocate

GO在程序启动的时候，会先向操作系统申请一块内存(这时还只是一段虚拟的地址空间，并不会真正地分配内存),切成小块后自己进行管理。

申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小。

arena区域就是所谓的堆区,Go动态分配内存都是在这个区域，它把内存分割为8kb大小的页,一些页组合起来称为mspan。

bitmap区域标识arena区域哪些地址保存了对象，并用4bit标志位标识对象是否包含指针、GC标记信息。bitmap中一个byte大小的内存对应arena区域中4个指针大小，所以bitmap区域的大小是16GB

bitmap的高地址指向arena区域的低地址部分,也就是说bitmap的额地址是由高向低增长的。

spans区域存放mspan(也就是一些arena分割的页组合起来的内存管理基本单元)的指针，每个指针对应一页,所以spans区域大小就是512MB.创建mspan的时候，按页填充对应的spans区域，在回收object时,根据地址很容易就能找到它所属的mspan。

## 内存管理单元

mspan: Go中内存管理的基本单元，是由一片连续的8KB的页组成的大块内存。注意，这里的页和操作系统本身的页不是一回事，它一般是操作系统页大小的几倍。一句话概括：mspan是一个包含起始地址、mspan规格、页的数量等内容的双端链表。

每个mspan按照它自身的属性size class的大小分割成若干个object,每个object可存储一个对象。并且会使用一个位图来标记其尚未使用的object。属性size class决定object大小,而mspan只会分配给object尺寸大小接近的对象，然而，对象的大小要小于object。

这是因为其实每个size class有两个mspan,也就是有两个span class。其中一个分配给含有指针的对象,另一个分配给不含有指针的对象。

根据mspan的Size Class可以得到它划分的object大小。 比如Size Class等于3，object大小就是32B。 32B大小的object可以存储对象大小范围在17B~32B的对象。而对于微小对象（小于16B），分配器会将其进行合并，将几个对象分配到同一个object中。

数组里最大的数是32768，也就是32KB，超过此大小就是大对象了，它会被特别对待，这个稍后会再介绍。顺便提一句，类型Size Class为0表示大对象，它实际上直接由堆内存分配，而小对象都要通过mspan来分配。