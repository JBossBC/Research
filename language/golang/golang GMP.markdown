# GMP


## 为什么引入协程

首先对于线程来说,一个线程被分为了用户态线程和内核态线程。内核态线程由操作系统进行调度管理,用户态线程由用户所调配管理。通常我们说的线程模型即一个用户态对应一个内核态线程。用户态线程的销毁和创建涉及到内核态线程的创建和销毁,这会导致用户态切换为内核态引发的上下文切换消耗过多的时间。内核态线程主要负责用户态线程的系统调用,用户态线程负责运行用户所提供的代码。从某种角度上来说,我只要能够满足在用户态线程需要进行系统调用时能够有内核态线程执行即可，也就是说,我可以让多个用户态线程去复用一个内核态线程,**避免只有一个用户态线程时，用户态线程的创建和切换以及删除会大量的时间去进行上下文切换**。这是协程引入的根本原因，至于另一个特点轻量，我认为是理所应当的产物,协程中只用保管一小部分寄存器用来进行计算的局部变量,以及被抢占时执行的位置即可。


golang早期使用全局队列来调度G给对应的M,也就是简单地使用一个队列来进行多对多的分配，这会造成全局锁竞争带来的性能下降问题。

对于协程的调度器来说，其实必不可少的需要谈论下面这点

+ 尽可能复用内核态线程(这是性能提升的核心所在),尽可能复用内核态线程这里所谈论的主要为两点:1、尽可能少的创建和删除所用的内核态线程，也就是说我们需要在协程的基础上复用内核态线程，我们会让内核态线程尽可能忙碌,被多个协程使用,从而防止内核态线程的创建和删除,自旋协程也是基于这个特点。2、尽可能的避免内核态线程的切换，传统的线程模型，只要线程切换就必定发生上下文的切换，这是因为用户态线程和内核态线程一对一的关系,那么现在协程的调度应该让这方面尽可能少的出现,通俗理解来说，即我优化为执行多个用户任务之后再进行必要的调度，而不是一个任务执行完即调度。


GOlang调度器针对以上问题做出了几种方案:

+ work stealing窃取:M可以从其他M绑定的P的运行队列偷取G来执行,当内核态线程A对应的P中的运行队列没有需要执行的G时,那么内核态线程A先从全局队列中查看是否有G，如果有就会根据负载均衡策略和效率取出一定的G来执行，如果全局队列中不存在G,那么就会从其他内核态线程所持有的G中根据策略去偷取。
+ hand off交接机制: 当M因为G调用syscall时阻塞,那么M为了不辜负本地队列中其他的G和P,会将P和本地队列"抛弃",从M的休眠队列中拿取一个新的M进行交付。
+ 基于协作的抢占机制:在一个本地队列,为了防止一个协程因为阻塞导致了其他协程不能有效执行,协程调度利用了进程调度同样的机制,"基于时间片调度",规定一个协程执行10ms时必须让出M的机制。
+ 基于信号的抢占式调度机制,这一点主要解决垃圾回收和栈扫描时无法被抢占的问题。
+ 比较有趣的是,为了防止僵尸协程的出现,在调度选择的时候，不是一直从本地队列中选取,在61次调度后会从全局队列中调度一次。同时,在本地队列满了的时候(2565个)再创建一个g时,golang会采取特殊的策略(将本地队列中靠前的一半进行打乱后和新创建的G一起放在全局队列中),**这部分很有意思, 这样做的原因其实很简单，当一个队列满的时候只有一种情况,本地队列中的g中创建了很多个协程,多到大于队列长度。从此刻来讲,为了防止一个协程通过创建很多协程的方式起到独占M的结果，最坏可能会导致全局队列一定程度上的未执行状态。对于一个优秀的调度器来讲，从这点尽量满足所有任务的雨露均沾,所以会采用这种特殊的方式调度**



## 总结

从以上的GMP模型我们可以反推goroutine有哪几种状态

首先一个合理的程序执行单元应该满足基本的几种状态

+ 创建
+ 就绪
+ 运行
+ 等待
+ 销毁

根据GMP模型的特点来讲,协程还有一种相对特殊的状态(系统调用的状态)。




