# Golang GC

垃圾回收器一直是被诟病最多，也是整个运行时中改进最努力的部分。所有变化都是为了缩短STW时间，提高程序实时性。


## 什么是垃圾回收机制

垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。

内存泄露是指该内存空间使用完毕之后未回收，内存泄漏过多导致内存溢出，导致应用程序所占内存超出系统限制，最终被系统杀掉。

## 什么是垃圾

这里的垃圾是指无用的对象或其他数据等已经不被需要，但却无法被GC所释放。

GC所使用的两种判断垃圾的算法

-  引用计数法

     引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1.当任何其它变量被赋值为这个对象的引用时，计数加1，但当一个对象实例的某个引用超过了声明周期或者被设置为一个新值时，对象实例到的引用计数器减1.任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1.

    引用计数法无法检测出循环引用，两个对象互相引用的情况下无法被检测出

- 可达性算法(根搜索算法)
    
    从根引用节点开始检索这个节点引用的节点，当所有的被引用节点都被找到后，剩余的节点则被认为是没有被引用的节点，需要被回收


GC所使用的几种回收算法

1. 标记清除算法 从根集合扫描，将存活的对象进行标记，标记完毕后再扫描一遍，对未进行标记的对象进行回收。标识清除算法不需要进行对象的移动，仅对不存活的对象进行处理，容易造成内存碎片。适用于存活率高的情况。
2. 复制算法 将可用内存空间分为两个部分，开始只使用其中的一半，在这一半用完后再将存活的对象复制到另外一块上。适用于存活率低的情况，避免了内存碎片的情况。
3. 标记整理算法 同标记清除算法一样进行标记，但在清除时将后面的对象在内存空间上向左移动，相比标记清楚来说成本更高，但没内存碎片的问题
4. 分代收集算法 对对象进行分代，不同代的对象采取不同的回收算法，提高效率。年轻代，新生成的对象都归为年轻代，年轻代在存放满和其他情况会触发minor GC。 老年代，大对象直接进入老年代，年轻代经历几次垃圾回收后仍然存活的对象也进入老年代。老年代存放满后触发Full GC



Golang的基本特征是"非分代、非紧缩、写屏障、并发标记处理"

与之前版本在STW状态上完成标记不同，并发标记和用户代码同时执行让一切都处于不稳定状态。用户代码随时可能修改已经被扫描过的区域，在标记过程中还会不断分配新对象，这让垃圾回收变得很麻烦。

究竟什么时候启动垃圾回收？过早会严重浪费CPU资源，影响用户代码执行性能。而太晚，会导致堆内存恶意膨胀。如何正确平衡这些问题就是个巨大的挑战。

所有问题的核心:抑制堆增长，充分利用CPU资源。


### 三色标记和写屏障

**这是让标记和用户代码并发的基本保障**,基本原理:

+ 起初所有对象都是白色。
+ 扫描找出所有可达对象，标记为灰色，放到待处理队列。
+ 从队列中提取灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。
+ 写屏障监视对象内存修改，重新标色或放回队列。

当完全全部扫描和标记工作后，剩余不是白色就是黑色，分别代表要待回收和活跃对象，清理操作只需将白色对象内存回收即可。