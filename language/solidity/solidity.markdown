# Solidity

Solidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。
solidity中智能合约的含义就是一组代码(它的功能)和数据(它的状态)的集合，并且它们是位于以太坊区块链的一个特定地址上的。**状态变量可以认为是数组库里的一个插槽，并且可以通过调用管理数据库代码的函数进行查询和更改**

要访问当前合约的成员，通常不需要像添加this.这样的前缀,你只需要通过名字就可以直接访问它。与其他一些语言不同的是，省略它不仅仅是一个风格的问题，因为它是一种完全不同的访问成员的方式。

该合约能完成的事情并不多:它允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用set，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。

**所有的标识符都只能使用ASCII字符集。UTF-8编码的数据可以用字符串变量的形式存储**

## 版本指令

所有的solidity源码都必须冠以"version pragma"-标明solidity编译器的版本，以避免将来新的编译器可能会破坏你的代码。


## 状态变量和整数

状态变量是被永久地保存在合约中，也就是说它们被写入以太币区块链中，想象成写入一个区块链。

+ 无符号整数 uint

uint无符号数据类型，指其数不能是负数，对于有符号的整数存在名为int的数据类型

> 注意:solidity中，uint实际上uint256代名词，一个256位的无符号整数，也可以定义位数少的uints-uint8,uint16,uint32;

**uint的设计:为什么要设计uint?这个在其他语言是很少见的，我们可以大胆猜想一下，solidity的设计原因是为了以太坊的智能合约编写，无论是比特币还是以太币本质上进行的交易都是价值的转换，只不过以太坊的智能合约让它具备了图灵完备性，能够进行复杂场景的价值交换。价值交换的展现就是货币交易，货币在设计的时候本就没有负数，为了方便，我们猜测这就是solidity编写者设计uint的原因**

## 结构体

solidity 结构体定义 struct 结构体名{}

## address

address类型是一个160位的值，且不允许进行任何的算数运算。这种类型适合存储合约地址或外部人员的密钥对。**关键字public自动生成一个函数,允许你在这个合约之外访问这个状态变量的当前值。如果没有这个关键字，其他的合约没有办法访问这个变量。

mapping(address=>uint)也创建一个公共状态变量，但是他是一个更复杂的数据类型，该类型将address映射为无符号整数。Mappings可以看作是一个哈希表他会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。但是，这种类比并不恰当，因为它既不能获得映射的所有键的列表，也不能获得所有值的列表。因此，要么记住你添加到mapping中的数据，要么在不需要键列表或值列表的上下文中使用它。

特殊函数constructor是仅在创建合约期间运行的构造函数，不能在创建之后调用。

## 特殊变量和函数

在全局命名空间中已经存在了一些特殊的变量和函数，它们主要是用来提供关于区块链的一些信息或一些通用的工具函数。为了方便理解，可以把这些变量和函数理解为solidity语言层面的原生API

### 区块和交易属性

+ blockhash(uint blockNumber)returns (bytes32)指定区块的区块哈希--仅可用于最新的256个区块且不包括当前区块，否则返回0.
+ block.basefee(uint):当前区块的基础费用
+ block.chainid(uint):当前链id
+ block.coinbase(address):挖出当前区块的矿工地址
+ block.difficulty(uint):当前区块难度
+ block.gaslimit(uint):当前区块gas限额
...

**对于每一个外部函数的调用，包括msg.sender和msg.value在内所有msg成员的值都会变化。这里包括对库函数的调用**

**当合约在链下被评估，而不是在一个区块所包含的交易的背景下被评估时，不应该假定block.\*和tx.\*是指任何特定区块或交易。这些值是由执行合约的EVM实现提供的，可以是任意的。**

**不要依赖block.timestamp和blockhash产生随机数，除非你明确知道自己做的用意。**

**时间戳和区块哈希在一定程度上都可能受到挖矿矿工影响。例如，挖矿社区的恶意矿工可以用某个给定的哈希来运行赌场合约的payout函数，而如果它们没收到钱，还可以用一个不同的哈希重新尝试。**

**当前的区块的时间戳必须严格大于最后一个区块的时间戳，但这里能确保也需要它是在权威链上的两个连续区块。**

### modifire(函数修饰符)

函数修饰符看起来根函数没什么不同，不过关键字modifier高速编译器，这是个modifier，而不是个function。它不能像函数那样直接被调用，只能被添加到函数定义的末尾，用来改变函数的行为。

一个函数执行的时候先执行该函数中的modifire函数。
记住，修饰符的最后一行为 _;，表示修饰符调用结束后返回，并执行调用函数余下的部分。

### 时间单位

solidity使用自己的本地时间单位

变量now将返回当前的unix时间戳(自1970年1月1日以来经过的秒数)。

注意：Unix时间传统用一个32位的整数进行存储。这会导致“2038年”问题，当这个32位的unix时间戳不够用，产生溢出，使用这个时间的遗留系统就麻烦了。所以，如果我们想让我们的 DApp 跑够20年，我们可以使用64位整数表示时间，但为此我们的用户又得支付更多的 gas。真是个两难的设计啊！

solidity还包括秒(seconds)，分钟(minutes),小时(hours),天(days),周(weeks)和年(years)等时间单位。它们都会转化成对应的秒数放入uint中。所以1分钟就是60，1小时就是3600……

### payable 修饰符

payable方法是一种可以接受以太的特殊函数

当你在调用一个普通网站服务器上的API函数的时候，你无法用你的函数传达美元--你也不能传送比特币。

但是在以太坊中，因为钱(_以太_)，数据(事务负载)，以及合约代码本身都存在于以太坊。你可以在同时调用函数并付钱给另一个合约。


## 代币

一个代币在以太坊基本上就是一个遵循一些共同规则的**智能合约**--即它实现了所有其他代币合约共享的一组标准函数，例如(transfer、balanceof)

在智能合约内部，通常有一个映射，mapping(address=>uint256)balances，用于追踪每个地址还有多少余额

所以基本上一个代币只是一个追踪谁拥有多少该代币的合约，和一些可以让那些用户将他们的代币转移到其他地址的函数

### why it is important

由于所有ERC20代币共享具有相同名称的同一组函数，它们都可以以相同的方式进行交互

这意味着如果你构建的应用程序能够与一个ERC20代币进行交互，那么它就也能够与其他任何ERC20代币进行交互。这样一来，将来你就可以轻松地将更多的代币添加到你的应用中，而无需进行自定义编码。你可以简单地插入新的代币合约地址，然后你的应用程序有另一个它可以使用的代币了。

其中一个例子就是交易所。当交易所添加一个新的ERC20代币时，实际上它只需要添加与之对话的另一个智能合约。用户可以让那个合约将代币发送到交易所的钱包地址，然后交易所可以让合约在用户要求取款时将代币发送回给它们。

交易所只需要实现这种转移逻辑一次，然后当它想要添加一个新的ERC20代币时，只需将新的合约地址添加到它的数据库即可。

有另一个代币标准更适合如CryptoZombies这样的加密收藏品--它们被称为ERC721代币。

ERC721代币是不能互换的，因为每个代币都被认为是唯一且不可分割的。你只能以整个单位交易它们，并且每个单位都有唯一的ID。这些特性正好让我们的僵尸可以用来交易。

### ERC721:转移标准

ERC721规范有两种不同的方法来转移代币

1. 第一种方法是代币的拥有者调用transfer方法，传入他想转移到的address和他想转移的代币的_tokenId.
2. 第二种方法是代币拥有者首先调用approve，然后传入与以上相同的参数。接着，该合约会存储谁被允许提取代币，通常存储到一个mapping(uint256 => address)里。然后，当有人调用takeOwnership时，合约会检查msg.sender是否得到拥有者的批准来提取代币，如果是，则将代币转移给他。

transfer和takeOwnership都将包含相同的转移逻辑，只是以相反的顺序(一种情况是代币的发送者调用函数；另一种情况是代币的接收者调用它)

### assert和require

assert和require相似，若结果为否它就会抛出错误。assert和require区别在于，require若失败则会返还给用户剩下的gas,assert则不会。所以大部分情况下，写代码的时候会比较喜欢require,assert只在代码可能出现严重错误的时候使用，比如uint溢出。

所以简而言之，SafeMath的add,sub,mul和div方法只做简单的四则运算，然后在发生溢出或下溢的时候抛出错误。

### 合约安全增强：溢出和下溢

为了防止因为变量的取值范围而出现的溢出情况，OpenZeppelin建立了一个叫做SafeMath的_库_,默认情况下可以防止这些问题。

一个_库_是solidity中一种特殊的合约。其中一个有用的功能是给原始数据类型增加一些方法
