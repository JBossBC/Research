# Solidity

Solidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。
solidity中智能合约的含义就是一组代码(它的功能)和数据(它的状态)的集合，并且它们是位于以太坊区块链的一个特定地址上的。**状态变量可以认为是数组库里的一个插槽，并且可以通过调用管理数据库代码的函数进行查询和更改**

要访问当前合约的成员，通常不需要像添加this.这样的前缀,你只需要通过名字就可以直接访问它。与其他一些语言不同的是，省略它不仅仅是一个风格的问题，因为它是一种完全不同的访问成员的方式。

该合约能完成的事情并不多:它允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用set，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。

**所有的标识符都只能使用ASCII字符集。UTF-8编码的数据可以用字符串变量的形式存储**

## 版本指令

所有的solidity源码都必须冠以"version pragma"-标明solidity编译器的版本，以避免将来新的编译器可能会破坏你的代码。


## 状态变量和整数

状态变量是被永久地保存在合约中，也就是说它们被写入以太币区块链中，想象成写入一个区块链。

+ 无符号整数 uint

uint无符号数据类型，指其数不能是负数，对于有符号的整数存在名为int的数据类型

> 注意:solidity中，uint实际上uint256代名词，一个256位的无符号整数，也可以定义位数少的uints-uint8,uint16,uint32;

**uint的设计:为什么要设计uint?这个在其他语言是很少见的，我们可以大胆猜想一下，solidity的设计原因是为了以太坊的智能合约编写，无论是比特币还是以太币本质上进行的交易都是价值的转换，只不过以太坊的智能合约让它具备了图灵完备性，能够进行复杂场景的价值交换。价值交换的展现就是货币交易，货币在设计的时候本就没有负数，为了方便，我们猜测这就是solidity编写者设计uint的原因**

## 结构体

solidity 结构体定义 struct 结构体名{}

## address

address类型是一个160位的值，且不允许进行任何的算数运算。这种类型适合存储合约地址或外部人员的密钥对。**关键字public自动生成一个函数,允许你在这个合约之外访问这个状态变量的当前值。如果没有这个关键字，其他的合约没有办法访问这个变量。

mapping(address=>uint)也创建一个公共状态变量，但是他是一个更复杂的数据类型，该类型将address映射为无符号整数。Mappings可以看作是一个哈希表他会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。但是，这种类比并不恰当，因为它既不能获得映射的所有键的列表，也不能获得所有值的列表。因此，要么记住你添加到mapping中的数据，要么在不需要键列表或值列表的上下文中使用它。

特殊函数constructor是仅在创建合约期间运行的构造函数，不能在创建之后调用。

## 特殊变量和函数

在全局命名空间中已经存在了一些特殊的变量和函数，它们主要是用来提供关于区块链的一些信息或一些通用的工具函数。为了方便理解，可以把这些变量和函数理解为solidity语言层面的原生API

### 区块和交易属性

+ blockhash(uint blockNumber)returns (bytes32)指定区块的区块哈希--仅可用于最新的256个区块且不包括当前区块，否则返回0.
+ block.basefee(uint):当前区块的基础费用
+ block.chainid(uint):当前链id
+ block.coinbase(address):挖出当前区块的矿工地址
+ block.difficulty(uint):当前区块难度
+ block.gaslimit(uint):当前区块gas限额