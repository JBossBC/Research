# Solidity

Solidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。
solidity中智能合约的含义就是一组代码(它的功能)和数据(它的状态)的集合，并且它们是位于以太坊区块链的一个特定地址上的。**状态变量可以认为是数组库里的一个插槽，并且可以通过调用管理数据库代码的函数进行查询和更改**

要访问当前合约的成员，通常不需要像添加this.这样的前缀,你只需要通过名字就可以直接访问它。与其他一些语言不同的是，省略它不仅仅是一个风格的问题，因为它是一种完全不同的访问成员的方式。

该合约能完成的事情并不多:它允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用set，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。

**所有的标识符都只能使用ASCII字符集。UTF-8编码的数据可以用字符串变量的形式存储**

## 版本指令

所有的solidity源码都必须冠以"version pragma"-标明solidity编译器的版本，以避免将来新的编译器可能会破坏你的代码。


## 状态变量和整数

状态变量是被永久地保存在合约中，也就是说它们被写入以太币区块链中，想象成写入一个区块链。

+ 无符号整数 uint

uint无符号数据类型，指其数不能是负数，对于有符号的整数存在名为int的数据类型

> 注意:solidity中，uint实际上uint256代名词，一个256位的无符号整数，也可以定义位数少的uints-uint8,uint16,uint32;

**uint的设计:为什么要设计uint?这个在其他语言是很少见的，我们可以大胆猜想一下，solidity的设计原因是为了以太坊的智能合约编写，无论是比特币还是以太币本质上进行的交易都是价值的转换，只不过以太坊的智能合约让它具备了图灵完备性，能够进行复杂场景的价值交换。价值交换的展现就是货币交易，货币在设计的时候本就没有负数，为了方便，我们猜测这就是solidity编写者设计uint的原因**

## 结构体

solidity 结构体定义 struct 结构体名{}

## address

address类型是一个160位的值，且不允许进行任何的算数运算。这种类型适合存储合约地址或外部人员的密钥对。**关键字public自动生成一个函数,允许你在这个合约之外访问这个状态变量的当前值。如果没有这个关键字，其他的合约没有办法访问这个变量。

mapping(address=>uint)也创建一个公共状态变量，但是他是一个更复杂的数据类型，该类型将address映射为无符号整数。Mappings可以看作是一个哈希表他会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。但是，这种类比并不恰当，因为它既不能获得映射的所有键的列表，也不能获得所有值的列表。因此，要么记住你添加到mapping中的数据，要么在不需要键列表或值列表的上下文中使用它。

特殊函数constructor是仅在创建合约期间运行的构造函数，不能在创建之后调用。

## 特殊变量和函数

在全局命名空间中已经存在了一些特殊的变量和函数，它们主要是用来提供关于区块链的一些信息或一些通用的工具函数。为了方便理解，可以把这些变量和函数理解为solidity语言层面的原生API

### 区块和交易属性

+ blockhash(uint blockNumber)returns (bytes32)指定区块的区块哈希--仅可用于最新的256个区块且不包括当前区块，否则返回0.
+ block.basefee(uint):当前区块的基础费用
+ block.chainid(uint):当前链id
+ block.coinbase(address):挖出当前区块的矿工地址
+ block.difficulty(uint):当前区块难度
+ block.gaslimit(uint):当前区块gas限额
...

**对于每一个外部函数的调用，包括msg.sender和msg.value在内所有msg成员的值都会变化。这里包括对库函数的调用**

**当合约在链下被评估，而不是在一个区块所包含的交易的背景下被评估时，不应该假定block.\*和tx.\*是指任何特定区块或交易。这些值是由执行合约的EVM实现提供的，可以是任意的。**

**不要依赖block.timestamp和blockhash产生随机数，除非你明确知道自己做的用意。**

**时间戳和区块哈希在一定程度上都可能受到挖矿矿工影响。例如，挖矿社区的恶意矿工可以用某个给定的哈希来运行赌场合约的payout函数，而如果它们没收到钱，还可以用一个不同的哈希重新尝试。**

**当前的区块的时间戳必须严格大于最后一个区块的时间戳，但这里能确保也需要它是在权威链上的两个连续区块。**

### modifire(函数修饰符)

函数修饰符看起来根函数没什么不同，不过关键字modifier高速编译器，这是个modifier，而不是个function。它不能像函数那样直接被调用，只能被添加到函数定义的末尾，用来改变函数的行为。

一个函数执行的时候先执行该函数中的modifire函数。
记住，修饰符的最后一行为 _;，表示修饰符调用结束后返回，并执行调用函数余下的部分。

### 时间单位

solidity使用自己的本地时间单位

变量now将返回当前的unix时间戳(自1970年1月1日以来经过的秒数)。

注意：Unix时间传统用一个32位的整数进行存储。这会导致“2038年”问题，当这个32位的unix时间戳不够用，产生溢出，使用这个时间的遗留系统就麻烦了。所以，如果我们想让我们的 DApp 跑够20年，我们可以使用64位整数表示时间，但为此我们的用户又得支付更多的 gas。真是个两难的设计啊！

solidity还包括秒(seconds)，分钟(minutes),小时(hours),天(days),周(weeks)和年(years)等时间单位。它们都会转化成对应的秒数放入uint中。所以1分钟就是60，1小时就是3600……

### payable 修饰符

payable方法是一种可以接受以太的特殊函数

当你在调用一个普通网站服务器上的API函数的时候，你无法用你的函数传达美元--你也不能传送比特币。

但是在以太坊中，因为钱(_以太_)，数据(事务负载)，以及合约代码本身都存在于以太坊。你可以在同时调用函数并付钱给另一个合约。
