#  bellman-ford

## 基本思路

首先n次迭代，每一次循环所有便，这里用abw表示存在一条a走到b的边，权重是w。dist数组表示每个点到起点的距离，那么更新操作就是dist[b]=min(dist[b],dist[a]+w),这样就可以更新和a相连的b点距离起点的距离，这个更新的过程就是**松弛操作**。 **没一次循环要先把dist数组备份一下，防止串联，循环n次后所有的边一定满足dist[b]<=dist[a]+w,这个叫三角不等式

如果图中有负权回路的话，最短路就不一定存在了。

bellman-ford算法是可以判断图中是否存在负权回路。首先上面的迭代次数是有意义的，比如我们迭代了k次，那么我们求的最短距离就是从1号点经过不超过k条边走到n号点的最短距离。所以在第n次迭代的时候又更新了某些边的话，就说明途径中一定存在环，并且是负权回路。因为第n次迭代不存在负权回路的情况是遍历到了第n号点，后面是没有点了，如果还能更新，说明路径中存在回路，并且是负权回路。

