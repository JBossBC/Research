# Socket

## Question

监听socket和已连接socket的区别

----

要想客户端和服务器能在网络中通信，那必须得使用socket编程，它使进程间通信里比较特别的方式，特别之处在于它是可以跨主机间通信。

服务器首先调用socket()函数，创建网络协议为IPv4,以及传输协议为TCP的Socket，接着调用bind()函数，给这个Socket绑定一个IP地址和端口。

+ 绑定端口的目的:当内核收到TCP报文，通过TCP头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。
+ 绑定IP地址的目的:一台机器是可以有多个网卡的，每个网卡都有对应的IP地址，当绑定一个网卡时,内核在收到该网卡上的包,才会发给我们。

绑定完IP地址和端口后,就可以调用listen()函数进行监听，此时对应TCP状态图中的listen,如果我们要判定服务器中一个网络程序有没有启动，可以通过netstat命令查看对应的端口号是否有被监听。

服务端进入了监听状态后，通过调用accept()函数，来从内核获取客户端的连接，如果没有客户端的连接，则会阻塞等待客户端连接到来。

客户端在创建好Socket后，通过connect()函数发起连接，该函数的参数要指明服务端的IP地址和端口号，然后TCP三次握手就开始了。

在TCP连接的过程中，服务器的内核实际上为每个Scoket维护了两个队列:

+ 一个是还没完全建立连接的队列，称为TCP半连接队列，这个队列都是没有完成三次握手的连接，此时服务端处于syn_rcvd的状态
+ 一个是已经建立连接的队列，称为TCP全连接队列，这个队列都是完成了三次握手的连接，此时服务端处于established状态

当TCP全连接队列不为空后，服务端的accept()函数，就会从内核中的TCP全连接队列里拿出一个已经完成连接的Socket返回应用程序，后续数据传输都用这个Socket。

注意:监听的socket和真正用来传数据的socket是两个:

+ 一个叫做监听socket
+ 一个叫做已连接socket

连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过read()和write()函数来读写数据

至此，TCP协议的socket程序的调用过程就结束了。 

基于linux一切皆文件的理念，在内核中socket也是以文件的形式存在的，也是有对应的文件描述符

每一个进程都有一个数据结构task_struct，该结构体里有一个指向文件描述符数组的成员指针。该数组里列出这个进程打开的所有文件的文件描述符。数组的下表是文件描述符，是一个整数。而数组的内容是一个指针，指向内核中所有打开的文件的列表，也就是说内核可以通过文件描述符找到对应打开的文件。

每个文件都有一个inode,socket文件的inode指向了内核中的socket结构，在这个结构体里有两个队列，分别是发送队列和接收队列，这两个队列里面保存的是一个个struct_sk_buff,用链表的组织形式串起来。

sk_buff可以表示各个层的数据包，在应用层数据包叫data，在TCP层我们称为segment,在IP层我们叫packet,在数据链路层称为frame。

## 如何服务更多的用户?

前面提到的TCP socket调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是同步阻塞的方式，当服务端在还没处理完一个客户端的网络IO时，或者读写操作发生阻塞时,其他客户端是无法与服务端连接的。

可如果我们服务器只能服务一个客户，那这样就太浪费资源了，于是我们要改进这个网络IO模型,以支持更多的客户端。

在改进网络IO模型前，服务器单机理论最大能连接多个客户端？

TCP连接是由四元组唯一确认的，这个四元组就是:本机IP,本机端口，对端IP，对端端口。

服务器作为服务方，通常会在本地固定监听一个端口,等待客户端的连接。因此服务器的本地IP和端口是固定的，于是对于服务器TCP连接的四元组只有对端IP和端口是会变化的，所以最大TCP连接数=客户端IP数*客户端端口数。

对于IPv4，客户端的IP数最多为2^32,客户端的端口数最多为2^16,也就是服务端单机最大TCP连接数约为2^48

服务器肯定承载不了那么大的连接数,主要会受到两个方面的限制:

+ 文件描述符:socket实际上是一个文件，也就是对应一个文件描述符。在linux下，单个进程打开的文件描述符是有限制的，没有经过修改的值一般都是1024,不过我们可以通过ulimit增大文件描述符的数目
+ 系统内存，每个TCP连接在内核中都有对应的数据结构，意味着每个连接都会占用一定内存的。

并发1万的请求，也就是经典的C10K问题，C是Client的缩写,C10K就是单机同时处理1万个请求的问题。

从硬件资源角度看，对于2GB内存千兆的服务器，如果每个请求处理占用不到200KB的内存和100Kbit的网络带宽就可以满足并发1万个请求。

不过，要想真正实现C10K的服务器，要考虑的地方在于服务器的网络IO模型，效率低的模型，会加重系统开销，从而会离C10K的目标越来越远

## 多进程模型

基于最原始的阻塞网络IO，如果服务器要支持多个客户端，其中比较传统的方式，就是使用多进程模型，也就是为每个客户端分配一个进程来处理请求。

服务器的主进程负责监听客户的连接,一旦与客户端连接完成，accept()函数就会返回一个已连接socket,这时就通过fork()函数创建一个子进程，实际上就把父进程所有相关的东西都复制一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。

这两个进程刚复制完的时候，几乎一模一样，不过会根据返回值来区分是父进程还是子进程,如果返回值是0，则是子进程;如果返回值是其他的整数，就是父进程.

正因为子进程会复制父进程的文件描述符,于是就可以直接使用已连接socket和客户端通信了。

可以发现，子进程不需要关心监听socket，只需要关心已连接sockeet;父进程则相反,将客户服务交给子进程来处理，因此父进程不需要关心已连接socket,只需要关心监听socket。

![](https://img-blog.csdnimg.cn/img_convert/43fcfcc841d44f3b3263d6cb995863ef.png)

另外，当子进程退出时，实际上内核还会保留该进程的一些信息，也是会占用内存的，如果不做好"回收工作"，就会变成僵尸进程，随着僵尸进程越多，会慢慢耗尽我们的系统资源。

因此