## 内核态与用户态

### Question

保护模式与实模式与用户态和内核态的区别(保护模式与实模式是CPU的运行模式)

### 用户态和内核态是操作系统的两种运行状态

### 内核态

处于内核态的CPU可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的CPU可以从一个程序切换到另一个程序，并且占用CPU不会发生抢占的情况，一般处于特权级0的状态我们称为内核态。内核进程/线程所在的区域。主要负责运行系统、硬件交互

### 用户态

处于用户态的CPU只能受限访问内存，并且并不会允许访问外围设备，用户态下的CPU不允许独占，也就是说CPU能够被其他程序获取。运行的代码需要受到CPU的很多检查，不能直接访问内核数据和程序，也就是说不可以像内核态线程一样访问任何有效地址。用户进程/线程所在的区域。主要用于执行用户程序。

### 为什么要有用户态和内核态

主要是访问能力的限制考虑，计算机中有一些比较危险的操作，比如设置时钟，内存清理，这些都需要在内核态下面进行，如果随意进行危险操作，极容易导致系统崩坏



### 用户态切换到内核态的方式

1、系统调用（主动）

由于用户态无法完成某些任务，用户态会请求切换到内核态，内核态通过为用户专门开放的中断完成切换。

2、异常（被动）

在执行用户程序时出现某些不可知的异常，会从用户程序切换到内核中处理该异常的程序，也就是切换到了内核态。

3、外围设备中断（被动）

外围设备发出中断信号，当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进程处理，如果中断之前CPU执行的是用户态程序，就相当于从用户态向内核态的切换。



### 总结:

**一个进程由于执行系统调用或者异常处理或者其他操作开始执行内核代码，我们称该进程处于内核态，一个进程执行应用程序自身代码则称该进程处于用户态**

针对不同的级别，有很多的限制，比如说传统的in，out指令，就是端口的输入输出指令，在0级下面是可以用的，但是在三级就不能用，你如果使用就会产生陷阱，告诉你出错了，当然限制还有很多，并不只是这一点。操作系统下是利用这个特点，当操作系统自己的代码运行时，CPU就切成0级，当用户的代码运行时就只让他在3级运行，这样如果用户的程序想做什么破坏系统的事情的话，也没办法做到。当然，低级别的程序是没法把自己升到高级别的，也就是说，用户程序运行在3级，他想把自己变成0级自己是做不到的，除非操作系统帮忙，利用这个特性，操作系统就可以控制所有程序的运行，确保系统的安全了，平时把操作系统运行时的级别就叫内核态，而且普通用户程序运行时的那个级别叫用户态

当操作系统刚引导时,CPU处于实模式，这时就相当于是0级，于是操作系统就自动得到最高权限，然后切换到保护模式时就是0级，这时操作系统就占了先机，成为了最高级别的运行者，由于你的程序都是由操作系统来加载的(进程的创建)，所以当他把你加载上来后，就把你的运行状态设为3级，然后才让你运行。这就是操作系统在内核态可以管理用户程序，杀死用户程序的原因。


### CPU怎么检查用户态代码执行是否有对应的权限

计算机的代码，都是机器码，都由CPU一条一条地执行的，无论是应用程序的代码，还是操作系统的代码，都是机器码，CPU都用一样的方法来执行，这个问题和内核态还是用户态无关。所以，没有“操作系统运行用户程序”的说法。所有的软件指令，都被CPU用一样的方法执行。

CPU如何知道现在执行的代码是不是操作系统的呢？一个最容易想到的解决办法就是：把操作系统的代码放在内存中一个特殊的区域，当CPU执行的指令地址来自这个区域时，就切换工作模式到Ring0，离开这个区域后，就切换到其他模式。光这样还不够，还得加一个措施：这个区域不能让应用程序来访问，否则谁都能来读写，那还了得？所以，除了指令增加特权级以外，在内存的访问上，也得加上特权级。x86架构的CPU是基于分段式+分页式相结合的内存管理方式，所以Intel倒腾了几下，给不同的内存段限定了不同的访问模式，并把它记录到了段的描述符。

