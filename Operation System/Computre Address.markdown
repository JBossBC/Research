# Address

## 物理地址

这里说的物理地址是内存中的内存单元实际地址，不是外部总线连接的其他电子元件的地址

物理地址就是内存中每个内存单元的编号，这个编号是顺序排好的，物理地址的大小决定了内存中有多少个内存单元，物理地址的大小由地址总线的位宽决定。

## 虚拟地址

虚拟地址是CPU保护模式下的一个概念，保护模式是80286系列和之后的X86兼容CPU操作模式，在CPU引导操作系统内核后，操作系统内核会进入一种CPU保护模式，也叫虚拟内存管理，在这之后的程序在运行时都处于虚拟内存当中，虚拟内存里的所有地址都是不直接的，所以你有时候可以看到一个虚拟地址对应不同的物理地址，比如A进程里的call函数入口虚拟地址是0x001，而b也是，但是他俩对应的物理地址却是不同的，操作系统利用这种内存管理方法

1. 防止程序对物理地址写数据造成一些不可必要的问题，比如知道了A进程的物理地址，那么向这个地址写入数据就会造成A进程出现问题，在虚拟进程中运行程序永远不知道自己处于内存中哪一段的物理地址上!现在的操作系统运行在保护模式下即便知道其他进程的物理地址也不允许向其写入!但是可以通过操作系统留下的后门函数获取该进程上的虚拟地址空间所有控制权限并写入指定数据
2. 虚拟内存管理采用一种拆东墙补西墙的形式，所以虚拟内存的内存要比物理内存大许多。在进入虚拟模式之前CPU以及Bootloader(Bootloader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境),操作系统内核均运行在实模式下，直接对物理地址进行操作。

虚拟内存中也有分页管理，这种管理方式是为了确保内存中不会出现内存碎片，当操作系统内核初始化完毕内存中的分页表后CPU的分页标志位会被设置，这个分页标志位是给MMU看的!

### 分页管理

内存分页其实就是我们所说的4G空间，内存的所有内存被操作系统内核以4G为每页划分开，当我们程序运行时会加载到内存中的4G空间里，其实说是有4G其实并没有真正在的4G空间，4G空间中有一小部分被映射到了物理内存中，或者被映射到了硬盘的文件上，或者没有被映射，还有一小部分在内存当中就会被划分栈、堆，其中有大片大片的内存是没有被映射的，同样物理内存也是被分页了用来与虚拟内存产生映射关系!

其实真正情况下只有3G用户空间，假如你的内存是4G的那么其中有1G是给操作系统内核使用的，所谓的4G空间只是操作系统基于虚拟内存这种拆东墙补西墙的形式给你一种感觉每个进程都有4G的可用空间。

