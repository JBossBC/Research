# Mysql Lock

数据库能够隐式加锁
+ 对于update、delete、insert语句，InnoDB会自动给涉及数据集加排他锁
+ MyISAM在执行查询语句select前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预

只会在某种特定的场景下才需要手动加锁

## 表锁

从锁的粒度，我们可以分为两大类:

+ 表锁:开销小，加锁快;不会出现死锁;锁定力度大,发生锁冲突概率高，并发度最低
+ 行锁:开销大,加锁慢;会出现死锁;锁定粒度小，发生锁冲突的概率低,并发度高

不同的存储引擎支持的锁粒度是不一样的
+ InnoDB行锁和表锁都支持
+ MyISAM只支持表锁

InnoDB只有通过索引条件检测数据才使用行级锁,否则InnoDB将使用表锁,InnoDB的行锁是基于索引的

### 表锁又分两种模式

+ 表读锁
+ 表写锁

在表读锁和表写锁的环境下:读读不阻塞，读写堵塞，写写阻塞!
      
               + 读读不阻塞:当前用户在读数据时，其他用户也在读数据，不会加锁
               + 读写阻塞:当前用户在读数据，其他的用户不能修改当前用户读的数据，会加锁!
               + 写写阻塞:当前用户在修改数据，其他用户不能修改当前用户正在修改的数据，会加锁

读锁和写锁是互斥的,读写操作是串行的

+ 如果某个进程想要获取读锁，同时另外一个进程想要获取写锁。在mysql里面,写锁是优先于读锁的
+ 写锁和读锁的优先级问题是可以通过参数调节的:max_write_lock_count和 low_priority-updates


MyISAM可以支持查询和插入操作的并发进行。可以通过concurrent_insert来指定哪种模式，在MyISAM中它默认是:如果MyISAM表中没有空洞(即表的中间没有被删除的行),MyISAM允许一个进程读表的时候，另一个进程从表尾插入记录,但是InnoDB存储引擎是不支持的。

### 行锁

