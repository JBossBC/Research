# What is database


## 数据库的发展历史

### 数据库1.0----文件系统

当我们需要存储图书馆的所有图书信息的时候，一开始我们将所有图书信息放在csv文件中

Book.csv ( title , author , year )
> "Gone with the Wind","Margaret Mitchell",1936
> 
> "Hamlet","William Shakespeare",1602
> 
> "活着","余华",1993
> 
> "三体","刘慈欣",2006

这种存储方式，实现起来简单，但当我们需要查询某一个图书内容的时候，这种存储模式，我们只能通过遍历的方式去查询，这是一种非常糟糕的查询方式。

面对庞大的数据量，数据被存放在多个文件里面。每次查询，我们需要打开多个文件，打开后还要遍历里面的数据，磁盘IO和时间复杂度都很高。

问题的根源在于:我们存储数据的时候是没有规律的

一旦存储数据的时候没有规律，在我们查找数据的时候，就只能"抹黑"查找，这极大降低了存储本身的意义。

所以，让数据规律存储，是优化这个文件系统的第一步。

### 数据库2.0---规律存储

让数据有规律的存储，一旦数据有规律，我们就可以使用各种算法去高效地查找他们。

让数据按照字典排序升序存储，于是我们可以进行二分查找，时间复杂度从o(n)->o(log2n)，缺点是每次插入都要排序

让书籍按照hash表的结构进行排序，于是我们可以进行hash查找，用空间换时间，时间复杂度是o(1)

让书籍按照二叉树的结果进行存储，于是我们可以进行二叉查找，时间复杂度为o(log2n)

二叉树极端的情况下会退化成o(n)，于是有了平衡二叉树

平衡二叉树终究还是二叉，只有两个节点，一次从磁盘load的数据太少了，于是有了可以有多于2个子节点的b树

b树找出来的数据是无序的，如果你要求数据排好序返回，还要在内存手动排一次序，于是有了叶子节点是一个双向链表的b+树


### 为什么最终决定用B+树呢

+ Hash(哈希表)

哈希表是做数据快速检索的有效利器

hash算法，也叫散列算法，就是把任意值(key)通过哈希函数变换为固定长度的key地址，通过这个地址进行具体数据的数据结构。考虑到这个数据库表user，表中一共有7个数据，我们需要检索id=7的数据，sql语法是 `select * from user where id=7;`哈希算法首先计算存储id=7的数据的物理地址，通过该独立地址可以找到对应数据。这就是哈希算法快速检索数据的计算过程。

但是hash算法有个数据碰撞问题，也就是hash函数可能对不同的key会计算出同一个结果。解决碰撞问题的一个常见处理方式就是链地址法，即用链表把碰撞的数据连接起来。计算hash值之后，还需要检查该hash值是否存在碰撞数据链表，有则一直遍历到链表尾，直到找到真正的key对应的数据之后

从算法的时间复杂度来看，hash算法的时间复杂度为O(1),检索速度非常快，为什么Mysql并没有采取hash作为底层存储算法呢？

1. 首先我们要考虑算法的优越性，不光要从时间复杂度来看，还需要从空间复杂度来看。key值经过hash转化指向元素value，先不考虑碰撞，因为虚拟内存是连续的，如果存储的两个value过大，那么进程会占用很大的空间来保证数据存储正确。
2. 数据检索不光是单个数据的查找，还有范围查找，比如下面这个SQL语句:
`select * from user where id>3;`
针对以上这个语句，我们希望查出id>3的数据。如果我们使用hash算法实现的索引，思路就是一次性把所有数据加载到内存中，然后再去内存里筛选目标范围内的数据。这种查找方式没有一点效率

+ 二叉查找树(BST)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca87b379915f46bd89f204185a93995c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

二叉查找树的时间复杂度是o(logn)，比如针对上面这个二叉树结构，我们只需要计算比较3次就可以检索到id=7的数据，相对于直接遍历查询省了一半的时间，从检索效率上看来是能做到高速检索的。此外二叉搜索树的结构还能解决哈希索引不能提供的范围查找功能。二叉搜索树的叶子节点都是按序排列的，从左到右依次升序排列，如果我们需要找id>5的数据，我们只需要取出节点为6的节点以及其右子树的就可以了。

但是普通的二叉查找树有一个致命的缺点，极端环境下会退化成线性表，二分查找也会退化成遍历查找，时间复杂度退化为O(n),检索性能急剧下降。在数据库中，数据的自增是一种很常见的形式，比如一个表的主键是id，而主键一般默认都是自增的，如果采用二叉搜索树作为索引，那么下面不平衡状态导致的线性查找问题必然出现。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca87b379915f46bd89f204185a93995c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

+ AVL树和红黑树

二叉查找树存在不平衡问题，学者提出通过树节点的自动旋转和调整，让二叉树始终保持基本平衡的状态，这样就能保持二叉搜索树的最佳查找性能了。

红黑树是一颗会自动调整树形态的树结构，比如当二叉树处于一个不平衡状态时，红黑树就会自动左旋右旋节点以及节点变色来调整树的形态，使其保持基本的平衡状态(时间复杂度为O(logn))，也就保证了查找效率不会明显降低.（红黑树牺牲了一定时间来构造一颗稳定的二叉搜索树来提高查找效率）

但是红黑树也存在相同的问题

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ae838e436ef4213a5da301a8db5bca1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)
