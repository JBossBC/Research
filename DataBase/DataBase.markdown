# What is database


## 数据库的发展历史

### 数据库1.0----文件系统

当我们需要存储图书馆的所有图书信息的时候，一开始我们将所有图书信息放在csv文件中

Book.csv ( title , author , year )
> "Gone with the Wind","Margaret Mitchell",1936
> 
> "Hamlet","William Shakespeare",1602
> 
> "活着","余华",1993
> 
> "三体","刘慈欣",2006

这种存储方式，实现起来简单，但当我们需要查询某一个图书内容的时候，这种存储模式，我们只能通过遍历的方式去查询，这是一种非常糟糕的查询方式。

面对庞大的数据量，数据被存放在多个文件里面。每次查询，我们需要打开多个文件，打开后还要遍历里面的数据，磁盘IO和时间复杂度都很高。

问题的根源在于:我们存储数据的时候是没有规律的

一旦存储数据的时候没有规律，在我们查找数据的时候，就只能"抹黑"查找，这极大降低了存储本身的意义。

所以，让数据规律存储，是优化这个文件系统的第一步。

### 数据库2.0---规律存储

让数据有规律的存储，一旦数据有规律，我们就可以使用各种算法去高效地查找他们。

让数据按照字典排序升序存储，于是我们可以进行二分查找，时间复杂度从o(n)->o(log2n)，缺点是每次插入都要排序

让书籍按照hash表的结构进行排序，于是我们可以进行hash查找，用空间换时间，时间复杂度是o(1)

让书籍按照二叉树的结果进行存储，于是我们可以进行二叉查找，时间复杂度为o(log2n)

二叉树极端的情况下会退化成o(n)，于是有了平衡二叉树

平衡二叉树终究还是二叉，只有两个节点，一次从磁盘load的数据太少了，于是有了可以有多于2个子节点的b树

b树找出来的数据是无序的，如果你要求数据排好序返回，还要在内存手动排一次序，于是有了叶子节点是一个双向链表的b+树


### 为什么最终决定用B+树呢

+ Hash(哈希表)

哈希表是做数据快速检索的有效利器

hash算法，也叫散列算法，就是把任意值(key)通过哈希函数变换为固定长度的key地址，通过这个地址进行具体数据的数据结构。考虑到这个数据库表user，表中一共有7个数据，我们需要检索id=7的数据，sql语法是 `select * from user where id=7;`哈希算法首先计算存储id=7的数据的物理地址，通过该独立地址可以找到对应数据。这就是哈希算法快速检索数据的计算过程。

但是hash算法有个数据碰撞问题，也就是hash函数可能对不同的key会计算出同一个结果。解决碰撞问题的一个常见处理方式就是链地址法，即用链表把碰撞的数据连接起来。计算hash值之后，还需要检查该hash值是否存在碰撞数据链表，有则一直遍历到链表尾，直到找到真正的key对应的数据之后

从算法的时间复杂度来看，hash算法的时间复杂度为O(1),检索速度非常快，为什么Mysql并没有采取hash作为底层存储算法呢？

1. 首先我们要考虑算法的优越性，不光要从时间复杂度来看，还需要从空间复杂度来看。key值经过hash转化指向元素value，先不考虑碰撞，因为虚拟内存是连续的，如果存储的两个value过大，那么进程会占用很大的空间来保证数据存储正确。
2. 数据检索不光是单个数据的查找，还有范围查找，比如下面这个SQL语句:
`select * from user where id>3;`
针对以上这个语句，我们希望查出id>3的数据。如果我们使用hash算法实现的索引，思路就是一次性把所有数据加载到内存中，然后再去内存里筛选目标范围内的数据。这种查找方式没有一点效率

+ 二叉查找树(BST)