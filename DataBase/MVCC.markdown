# MVCC

## Question


乐观锁+版本号

----


MVCC:多版本并发控制，通过这种机制可以做到读写不阻塞，且避免了类似脏读这样的问题，主要通过undo日志链来实现


## 当前读和快照读

+ 当前读:像select lock in share mode(共享锁),select for update;update;insert;delete(排他锁)这些操作都是一种当前读,它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。(读写锁控制事务的隔离性)
+ 快照读:像不加锁的select操作就是快照读,即不加锁的非阻塞读;快照读的前提是隔离级别不是串行级别,串行级别下的快照读会退化成当前读;之所以出现快照读的情况，是基于提高并发性能的考虑,快照读的实现是基于多版本并发控制，即MVCC，可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本,即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

**说白了MVCC就是为了实现读-写冲突不加锁，而这个读就是指的是快照读，而非当前读,当前读实际上是一种加锁操作，是悲观锁的实现**

## uodo日志

undo log分为两种:

+ insert undo log:代表事务在insert新纪录时产生的undo log,只在事务回滚时需要，并且在事务提交后可以被立即丢弃
+ update undo log:事务在进行update或delete时产生的undo log,不仅在事务回滚时需要，在快照读时也需要;所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清理


> purge:
>      
>      从前面的分析可以看出，为了实现innodb的mvcc机制，更新或者删除操作都只是设置一下老记录的deleted_bit,并不真正将过时的记录删除。
>      
>      为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit的记录。为了不影响MVCC的正常工作，purge线程也自己维护了一个read view(这个 read view相当于系统中最老活跃事务的read view);如果某个记录的deleted_bit为true,并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。  

read commit:语句级快照

repeatable read:事务级快照



