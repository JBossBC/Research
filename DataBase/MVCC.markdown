# MVCC

## Question

不可重复度和读已提交之间的read view视图，不可重复度在每事务开启的时候构造read view，读已提交在每次构建快照读的时候创建read view。相比之下读已提交花费的花费的资源更多，那么为什么我们不直接去掉读已提交？



----

MVCC:多版本并发控制，通过这种机制可以做到读写不阻塞，且避免了类似脏读这样的问题，主要通过undo日志链来实现

## 乐观锁和悲观锁

悲观锁基于数据库中的锁机制实现的，乐观锁和悲观锁只是一种设计理念和不是具体的锁机制。乐观锁与悲观锁的区别在于,是否认为操作实现之后是否不满足事务之间的隔离性以及原子性。所谓乐观在于认为每次对数据库的操作大多数都是对数据库的读操作，不会改动数据库里面的数据，这种情况下，对于多事务来说,不需要在内部进行锁机制的实现来确保数据一致性。所谓悲观在于认为每次对数据库的操作大多数都会改变数据库的数据，这种情况下，为了确保数据在多事务中的数据一致性,我们需要加锁来确保事务之间的部分原子性。

乐观锁的实现通常通过创建表中额外字段(version/update_time)来实现,读取数据时，判断当前数据是否为最新数据，如果不是，那就重新取,如果是，则进行改动,并且修改额外字段(version/update_time)

悲观锁的实现通常使用数据库中的锁,在innodb存储引擎中，使用行锁来实现,悲观锁的主要应用场景为写-写场景下,所以会造成阻塞问题的出现。

## 当前读和快照读

+ 当前读:像select lock in share mode(共享锁),select for update;update;insert;delete(排他锁)这些操作都是一种当前读,它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。(读写锁控制事务的隔离性)
+ 快照读:像不加锁的select操作就是快照读,即不加锁的非阻塞读;快照读的前提是隔离级别不是串行级别,串行级别下的快照读会退化成当前读;之所以出现快照读的情况，是基于提高并发性能的考虑,快照读的实现是基于多版本并发控制，即MVCC，可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本,即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

**说白了MVCC就是为了实现读-写冲突不加锁，而这个读就是指的是快照读，而非当前读,当前读实际上是一种加锁操作，是悲观锁的实现**


## MVCC的实现原理

mvcc的实现原理主要是依赖记录中的3个隐式字段，以及undo日志和read view来实现的


### 隐式字段

每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID，DB_ROLL_PTR,DB_ROW_ID等字段

+ DB_TRX_ID:6yte,最近修改事务ID:记录创建这条记录或者最后一次修改该记录的事务ID
+ DB_ROLL_PTR:7byte,回滚指针，指向这条记录的上一个版本(存储于rollback segment)
+ DB_ROW_ID:6type,隐含的自增ID，如果数据表没有主键,InnoDB会自动以DB_ROW_ID产生一个聚簇索引


## uodo日志

undo log分为两种:

+ insert undo log:代表事务在insert新纪录时产生的undo log,只在事务回滚时需要，并且在事务提交后可以被立即丢弃
+ update undo log:事务在进行update或delete时产生的undo log,不仅在事务回滚时需要，在快照读时也需要;所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清理


> purge:
>      
>      从前面的分析可以看出，为了实现innodb的mvcc机制，更新或者删除操作都只是设置一下老记录的deleted_bit,并不真正将过时的记录删除。
>      
>      为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit的记录。为了不影响MVCC的正常工作，purge线程也自己维护了一个read view(这个 read view相当于系统中最老活跃事务的read view);如果某个记录的deleted_bit为true,并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。  


## read view 读视图

read view就是事务进行快照读操作的时候产生的读视图,在该事务执行的快照读的那一刻,会生成数据库系统当前的一个快照,记录并维护系统当前活跃事务的ID(当每个事务开始时,都会被分配一个ID，这个ID时递增的,所以最新的事务,ID值越大)

所以read view 主要是用来做**可见性判断**的,即当我们某个事务执行快照读的时候，对该记录创建一个read view读视图，把它比作条件来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log 里面的某个版本的数据。

read view遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID(即当前事务ID)取出来，与系统当前其他活跃事务的ID去比对(由read view维护),如果DB_TRX_ID跟read view的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出undo log中的DB_TRX_ID再比较，即遍历链表DB_TRX_ID,直到找到满足特定条件的DB_TRX_ID,那么这个DB_TRX_iD所在的旧记录就是当前事务能看到的最新老版本


## RC,RR级别下的InnoDB快照读有什么不同

read view生成的时机不同，从而造成RC,RR级别下快照读的结果不同

+ 在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及read view,将当前系统活跃的其他事务记录起来，此后调用快照读的时候，还是使用的同一个read view，所以只要当前事务在其他事务提交更新之前使用过快照读,那么之后的快照读使用的都是同一个read view，所以对之后的修改不可见
+ 在RR级别下,快照读生成Read view时,read view会记录此时所有其他活动事务的快照,这些事务的修改对于当前事务都是不可见的。而早于Read view创建的事务所做的修改均是可见的
+ 而在RC级别下的,事务中,每次快照读都会新生成一个快照和Read view,这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因

总之在RC隔离级别下，是每个快照读都会生成并获取最新的read view,而在rr隔离级别下，则是同一个事务中的第一个快照才会创建read view,之后的快照读获取的都是同一个read view。



read commit:语句级快照

repeatable read:事务级快照



