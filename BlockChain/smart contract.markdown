# smart contract

## 函数的修饰符

上面的函数实际上没有改变solidity里的状态，即他没有改变任何值或者写任何东西。这种情况下我们可以把函数定义为view，意味着它只能读取数据不能更改数据

solidity还支持pure函数，表明这个函数甚至都不访问应用里的数据


### 公共函数

solidity定义的函数的属性默认为公共，意味着任何一方(或其他合约)都可以调用你合约里的函数

### 私有函数

私有函数意味着只有在本合约中的其他函数才能调用这个函数，在函数名字后面使用关键字private即可。和函数的参数类似，私有函数的名字用(_)起始


## hash function

Ethereum内部有一个散列函数keccak，他用了sha版本。一个散列函数基本上就是把一个字符串转换为一个位的进制数字。字符串的一个微小变化会引起散列数据极大变化.


## event

事件是合约和区块链通讯的一种机制。你的前端应用监听某件事情，并做出反应。事件是使用EVM日志内置功能的方便工具，在DAPP的接口中，它可以反过来调用JavaScript的监听事件的回调。

事件在合约中可被继承。当被调用时，会触发参数存储到交易的日志中(一种区块链上的特殊数据结构)。这些日志与合约的地址关联，并合并到区块链中，只要区块可以访问就一直存在。日志和事件在合约内不可直接被访问，即使是创建日志的合约。

如果外部实体需要该日志实际上存在于区块链中的证明，可以请求日志的merkle证明，但需要留意的是，**由于合约中仅能访问最近的256个区块哈希，所以还需要提供区块头信息。**

## address

以太坊区块链由_account_(账户)组成，你可以把它想象成银行账户。一个账户的余额是_以太_(在以太坊区块链上使用的币种),你可以和其他账户之间支付和接收以太币，就像你的银行账户可以电汇资金到其他银行账户一样。

每个账户都有一个地址，你可以把它想象成一个银行账号。


## msg.sender

在solidity中，有一些全局变量可以被所有函数调用。其中一个就是msg.sender，它指的是当前调用者(或智能合约)的address。

> 注意:在solidity中，功能执行始终需要从外部调用者开始。一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以msg.sender总是存在的。

> 使用msg.sender很安全，因为它具有以太坊区块链的安全保障--除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人得到数据的。


## require

require使得函数在执行过程中，当不满足某些条件时抛出错误，并**停止执行**

## 继承

当我们的代码越来越长，最好将代码和逻辑分拆到多个不同的合约，以便于管理。

solidity支持多重继承包括多态。

所有的函数调用都是虚拟的，这意味着最终派生的函数会被调用，除非明确给出合约名称或者使用super关键字。

当一个合约从多个合约继承时，在区块链上只有一个合约被创建，所有基类合约(父合约)的代码被编译到创建的合约中。这意味着对基类合约函数的所有内部调用也只是使用内部函数调用(super.f(..)将使用jump跳转而不是消息调用)

状态变量覆盖被视为错误。派生合约不可以在声明已经是基类合约中可见的状态变量具有相同的名称。

## 引入(import)

在solidity中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用import语句

## Storage与memory

在solidity中，有两个地方可以储存变量--storage与memory

storage变量是指永久存储在区块链中的变量。memory变量则是临时的，当外部函数对某个合约调用完成时，内存型变量即被删除。可以把它想想成存储在你电脑的硬盘或是RAM中数据的关系。

大多数时候你都用不到这些关键字，默认情况下solidity会自动处理他们，状态变量(在函数之外声明的变量)默认为存储形式，并永久写入区块链1；而在函数内部声明的变量是内存型的，它们函数调用结束后消失。

## Internal 和 external

除public和private属性之外，solidity还使用了另外两个描述函数可见性的修饰词:internal(内部)和external(外部)。

internal和private类似，不过，如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的"内部"函数。

external和public 类似，只不过这些函数只能在合约之外调用-它们不能被合约内的其他函数调用？？？