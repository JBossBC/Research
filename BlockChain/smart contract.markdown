# smart contract

## 函数的修饰符

上面的函数实际上没有改变solidity里的状态，即他没有改变任何值或者写任何东西。这种情况下我们可以把函数定义为view，意味着它只能读取数据不能更改数据

solidity还支持pure函数，表明这个函数甚至都不访问应用里的数据


### 公共函数

solidity定义的函数的属性默认为公共，意味着任何一方(或其他合约)都可以调用你合约里的函数

### 私有函数

私有函数意味着只有在本合约中的其他函数才能调用这个函数，在函数名字后面使用关键字private即可。和函数的参数类似，私有函数的名字用(_)起始


## hash function

Ethereum内部有一个散列函数keccak，他用了sha版本。一个散列函数基本上就是把一个字符串转换为一个位的进制数字。字符串的一个微小变化会引起散列数据极大变化.


## event

事件是合约和区块链通讯的一种机制。你的前端应用监听某件事情，并做出反应。事件是使用EVM日志内置功能的方便工具，在DAPP的接口中，它可以反过来调用JavaScript的监听事件的回调。

事件在合约中可被继承。当被调用时，会触发参数存储到交易的日志中(一种区块链上的特殊数据结构)。这些日志与合约的地址关联，并合并到区块链中，只要区块可以访问就一直存在。日志和事件在合约内不可直接被访问，即使是创建日志的合约。

如果外部实体需要该日志实际上存在于区块链中的证明，可以请求日志的merkle证明，但需要留意的是，**由于合约中仅能访问最近的256个区块哈希，所以还需要提供区块头信息。**

## address

以太坊区块链由_account_(账户)组成，你可以把它想象成银行账户。一个账户的余额是_以太_(在以太坊区块链上使用的币种),你可以和其他账户之间支付和接收以太币，就像你的银行账户可以电汇资金到其他银行账户一样。

每个账户都有一个地址，你可以把它想象成一个银行账号。


## msg.sender

在solidity中，有一些全局变量可以被所有函数调用。其中一个就是msg.sender，它指的是当前调用者(或智能合约)的address。

> 注意:在solidity中，功能执行始终需要从外部调用者开始。一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以msg.sender总是存在的。

> 使用msg.sender很安全，因为它具有以太坊区块链的安全保障--除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人得到数据的。


## require

require使得函数在执行过程中，当不满足某些条件时抛出错误，并**停止执行**