# 跨链

关于跨链需要知道的第一件事情是，我们永远没有办法把一条链上的资产真正的转移到另一条链上


那用跨链实现的资产转移是在做什么？它是在一条链上锁定资产，在另一条链上发行该资产的等值替代品

以比特币和以太坊之间的跨链为例，它需要你把比特币转入某个地址，锁定这部分比特币，然后在以太坊上发行比特币替代品，并转入你在以太坊上的地址；赎回的时候，需要你调用智能合约销毁比特币替代品，然后在比特币网络上把锁定的比特币释放给你。

不难发现，这其中唯一的难点就在于消息的互通。

也就是说，当你在比特币网络把比特币锁定后，只要以太坊能知道这件事，就可以在以太坊上铸币给你；当你在以太坊把替代品销毁后，只要比特币网络能知道这件事，就可以在比特币网络上释放币给你。


## 完美跨链为何难以实现


公链技术发展面临的主要问题是如何突破性能和成本瓶颈，同时不过度牺牲链上应用的可组合性。目前看有三个解决方案：分片、Layer 2、多链（跨链）。Polkadot、Cosmos、Ava，还有包括Cdot 在内的众多团队，做得就是多链这个方向。


也就是说，如果可以用Substrate /Cosmos SDK 为每个加密协议开发出专用的链，又可以通过跨链，让这个加密协议可以跟其他加密协议互操作，那么公链的性能和成本问题就可以得到解决。


跨链技术分成了三类，哈希时间锁、见证人、中继

见证人和中继都是链下进程，它们负责把消息转来转去：它看到A链上发生了一件事，就告诉B链（注：负责两条链消息的互通）。


那它俩的区别是什么？当我在目标链上收到一个消息后，如果是见证人跨链，我验证的是这条消息来自于见证人，如果我相信见证人，我就相信这个消息，就执行该执行的操作。

如果是中继跨链，我验证的不是这条消息来自于哪个中继，我验证的是这条消息是不是来自于源链，如果是，就执行该执行的操作。

也就是说，见证人可以看做是需要被信任的中继，中继可以看做是无需被信任的见证人。这就是两者的核心区别，中继显然比见证人更符合trustless 的原则。

中继是无法做恶的，如果一个中继提交的信息不是来自于源链，目标链验证之后会把它识别出来。但是见证人是可以做恶的，它可以造出一个消息发给目标链，目标链验证它是来自于自己相信的见证人后，就会执行这个操作。

这样看来，似乎大家都应该用中继去做跨链产品，但为什么还存在见证人方式？因为中继跨链的要求比较高。


它的要求到底是什么？假设咱们是两条链，你上面发生了一个事件，由一个中继发给了我，我要验证这个信息来自于你这条链，对吧？

怎么验证呢？我的链上需要有你的链的轻客户端。可以粗略地理解为类似于比特币SPV 的机制，但发生在链上，而不是在手机钱包里，即你的所有区块头我这儿都要有。

这个时候，当一条消息过来，中继不但要把消息给我，还要把消息的证明给我，这个证明是一个Merkle Proof，它告诉我这个事件或这笔交易是发生在你这条链上的哪个区块（高度）。

我拿到Merkle Proof 后，因为有你所有的区块头，就可以把对应高度的区块头拿出来，用Merkle Proof 验证这个交易或者这个事件是否存在。如果存在性得到证明，我就确定了这个消息确实是源自于你这条链的。

然后，当我这条链生成一个事件或者发生一笔交易后，中继也发给你，你也有我全部的区块头，也可以验证这个消息是否来自于我。这是一个完美的跨链，对吧？

可为什么大家不去实现完美的中继跨链呢？因为有些链是没有办法实现别的链的轻客户端的。比如比特币，它上面实现不了任何一个链的轻客户端。

以太坊上能不能实现别的链的轻客户端呢？要看实现的难度。以太坊需要用智能合约实现轻客户端，但智能合约是有gas 限制的，所以轻客户端验证的计算量是要能够容纳到Gas Limit 以内的。

问：可不可以这么认为，如果一个链不具备实现另外一个链的轻客户端的条件，它就永远无法以中继的方式与另一个链跨链？

刘毅：它就只能用见证人的方式跨链，但可以混合，一个方向上用见证人，另外一个方向上用中继。

比如我开发一条链，比特币肯定实现不了我的轻客户端，但我可以实现比特币的轻客户端，那么比特币到我这个方向能够用中继，我到比特币这个方向就只能用见证人。


比如一个Tendermint（Cosmos 采用的共识协议）的链，中继跨链需要验证它的区块头，它的区块头是所有验证者的签名，这些签名用的是BLS 签名算法，验证区块头就要验证这些BLS 签名，但是，以太坊上没有预编译BLS 签名。

智能合约可以直接调用预编译加密算法，比如调ECRecover 方法，用它验证ECDSA 签名只需要3000 gas，还是比较低的；但验证没有预编译的 BLS 签名，就得把整个的签名验证算法Solidity 实现，不是底层支持的，这个太贵了。

验证一个BLS 签名，最优好像是二十几万gas，如果Tendermint 上有100个验证人，那每个区块可能就有100 个签名，验证100 个BLS 签名，gas 肯定会超，不可能做到。

不过今年Vitalik 写的路线图上，以太坊1.x 会增加BLS 签名预编译合约，相当于在客户端底层实现BLS 验证，那么一个函数调用就可以验证签名。

假设和ECDSA 一样，也是3000 gas，那验证100 个BLS 签名是三十万gas，这就有可能在智能合约里实现。

有了BLS 预编译后，理论上就可以在以太坊上实现Tendermint 的轻客户端，那么以太坊和Cosmos 就可以实现双向的中继跨越。所以说和Cosmos 中继跨链的话，比特币肯定不行，以太坊是现在不行，未来可能行。


## 跨链消息如何在链间传递


** 跨链桥很形象，它有两个桥墩和一个桥梁。两个桥墩就是两套智能合约（有些链可能叫模块），一个运行在A 链，一个运行在B 链；中间是桥梁，桥梁是链下进程，负责监控两边这两套智能合约的事件。**


问：比如我在以太坊上把一只加密猫锁进了智能合约，链下进程监听到这个事件很容易，但它怎么告诉Flow 上的智能合约我锁了一只猫？

刘毅：链下进程就是给Flow 发一笔交易，说以太坊这边锁了一只猫，你那边要铸造出一只猫。它是一个程序，通过RPC（远程过程调用）接口，一边连以太坊的节点，另一边连Flow 的节点。

问：能完整描述一个具体的跨链过程吗？

刘毅：假设现在有一个ERC20 的代币，比如说是UNI，它发行在以太坊上，我们想把它跨到PlatON 上面去。

那么以太坊这边要有一个智能合约，比如叫Vault 合约，它是跨链桥的一个桥墩；跨链的用户要做两笔交易，第一笔交易是调用UNI 合约的Approve 方法，允许Vault 合约转走多少用户的UNI。

第二笔交易是发给Vault 合约的Lock 方法，把要锁定的币种（本例是UNI）和数量（比如500 个） 作为参数传进去，然后还要提供一个PlatON 的地址，说我锁500 个是为了在这个地址上铸造出500 个UNI 的替代品。

这个时候，Vault 合约就会去调用UNI 合约做UNI 的转移，因为Vault 合约已经被Approve 了，就可以把UNI 从用户地址转到Vault 合约的地址上，也就是把UNI 锁住。

锁完之后，Vault 合约就会发一个事件，比如叫AssetLock 事件；链下进程是通过RPC 接口连在以太坊节点上的，它会订阅Vault 合约的AssetLock 事件，这个事件只要一出现在日志里，链下进程就得到这个事件了。

这个事件里包含相关参数，比如锁定的是哪个币，锁了多少，另一条链上的受益人是谁；链下进程会等待比如说100 个块的确认，不可逆转；然后，链下进程也有一个连接PlatON 的RPC 接口，它会提交一笔交易到PlatON，假设这笔交易叫Mint。

PlatON 上也会有一个合约，比如叫Control 合约，它是跨链桥的另一个桥墩；Control 合约事先会创建一个类似ERC20 的合约，比如叫EUNI，Control 合约是这个合约的owner，也就是说它有权力控制EUNI 合约的代币供应。

Control 合约收到Mint 请求后，验证这个请求确实来自于见证人，就会调用EUNI 合约的Mint 方法，告诉它给某个地址铸造500 个EUNI 代币；EUNI 铸造出来后，就会放在用户之前提供的地址上，用户就可以用了。

这个时候，假设用户把EUNI 转给了另外一个用户，新用户想要以太坊上的UNI，那他要做的操作是先Approve，然后调用Control 合约的Redeem 方法，烧掉比如说100 个EUNI，并释放一个事件叫AssetBurn。

链下进程监控到Control 合约的AssetBurn 事件，就会给以太坊Vault 合约发一个交易请求，调用Release 接口，以太坊验证这个交易是来自于见证人后，就会把UNI 从Vault 合约的地址上转移到指定的用户地址上，用户就得到了原始的UNI。这就是一个完整的跨链过程。

问：可以抛开「链下进程」这个角色实现跨链吗？比如一条链直接去监听另一条链，然后完成相关的跨链操作？

刘毅：这是做不到的，因为链都不能主动发起操作，链的逻辑都是被动的。

唯一的例外是Substrate（Polkadot开发框架），它上边有off-chain worker 这个机制，可以用一个链下工作机发起请求。其他的，比如以太坊智能合约，是不能自己主动发起干什么事的，它只有被调用。

问：可不可以这么理解，不管是中继跨链还是见证人跨链，都需要链下进程来传递消息，所不同的是，中继跨链通过轻客户端验证消息，见证人跨链信任见证人提供的消息？

刘毅：这样理解基本上没有问题。中继跨链依赖链下进程的可用性，但不依赖它的忠诚。