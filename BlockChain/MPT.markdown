# MPT

MPT提供经加密验证的数据结构，可用于存储所有(key,value)对

MPT完全具有决定性，意味着可以保证具有相同(key,value)对的前缀树从第一个到最后一个字节完全相同。这意味着他们有相同的根哈希值，从而提供强大的O(logn)级别的插入、查找和删除效率，此外，与其他更复杂的基于比较的数据结构(如红黑树)相比，它们更容易理解和编码


## 基数树

在一个基数树中，每个节点如图下所示

     [0,i1...in,值]

其中i0...in表示字母表中的符号(通常以二进制或十六进制方式表示),value是该节点的终值，而i0...in时隙的值要么是null要么是其他节点的指针。这形成了基本的(key,value)存储。例如，如果你想获取当前映射到 dog 的值，首先需要将 dog 转换成字母表中的字母（分别为 64 6f 67），然后按该路径依次向下遍历前缀树，直至找到对应的值。 也就是说，首先要从一个固定“键/值”数据库中查询根哈希值，以找到前缀树的根节点（一个其他节点的键数组），然后将索引 6 的值用作键（并在固定“键/值”数据库中查询它对应的值）找到下一个节点。继续选择索引 4 来查找下一个值。再选择索引 6，循环往复，直到走过了以下路径：root -> 6 -> 4 -> 6 -> 15 -> 6 -> 7，此时所在节点的值就是要查询的值，然后返回结果。

从前缀树中查询和从其底层的固定“键/值”数据库中查询存在差异。 它们都定义了“键/值”对，但底层数据库能实现传统的 1 步查询，得到键对应的值。 而在前缀树中查询一个键对应的值则需要在底层数据库中查询多次才能得到最终结果。 我们把后者的查询方式称作 path，以避免描述上的模糊。