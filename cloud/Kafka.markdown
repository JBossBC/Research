# kafka

+ **消息系统**： Kafka 和传统的消息系统（也称作消息中间件）都具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。与此同时，Kafka 还提供了大多数消息系统难以实现的消息顺序性保障及回溯消费的功能。
+ **存储系统**： Kafka 把消息持久化到磁盘，相比于其他基于内存存储的系统而言，有效地降低了数据丢失的风险。也正是得益于 Kafka 的消息持久化功能和多副本机制，我们可以把 Kafka 作为长期的数据存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题的日志压缩功能即可。

+ **流式处理平台**： Kafka 不仅为每个流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理类库，比如窗口、连接、变换和聚合等各类操作。


## 基本概念

一个典型的Kafka架构包括若干Producer、若干Broker、若干Consumer，以及一个ZooKeeper集群。其中Zookeeper是kafka用来负责集群元数据的管理、控制器选举等操作的。producer将消息发送到Broker，Broker负责将收到的消息存储到磁盘中，而Consumer负责从Broker订阅并消费消息




1. Producer:生产者，负责发送消息的一方.生产者负责创建消息,然后将其投递到Kafka中。
2. Consumer:消费者，也就是接收消息的一方。消费者连接到kafka上并接收消息，进而进行相应的业务逻辑处理。
3. Broker:服务代理节点。对于Kafka而言，Broker可以简单地看作一个独立的kafka服务节点或kafka服务实例。
4. 主题和分区。主题是一个逻辑上的概念，它还可以细分为多个分区，一个分区只属于单个主题，很多时候也会把分区称为主题分区(Topic-Partition)。同一个主题下的不同分区包含的消息是不同的，分区在存储层面可以看作一个可追加的日志文件，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量(offset)。offset是消息在分区中的唯一标识，kafka通过它来保证消息在分区中的顺序性，不过offset并不跨越分区，也就是说，kafka保证的是分区有序而不是主题有序。消息被顺序追加到每个分区日志文件的尾部。**kafka中的分区可以分布在不同的服务器上，也就是说，一个主题可以横跨多个broker，以此来提供比单个broker更强大的性能**。



每一条消息被发送到broker之前，会根据分区规则选择存储到哪个具体的分区。如果分区规则设定得合理，所有的消息都可以均匀地分配到不同地分区中。如果一个主题只对应一个文件，那么这个文件所在的机器I/O将会成为这个主题的性能瓶颈，而分区解决了这个问题。在创建主题的时候可以通过指定的参数来设置分区的个数，当然也可以在主题创建完成之后去修改分区的数量，通过增加分区的数量可以实现水平扩展。

kafka为分区引入了多副本机制，通过增加副本数量可以提升容灾能力


同一分区的不同副本中保存的是相同的信息(在同一时刻，副本之间并非完全一样)---一致性问题，副本之间是一主多从的关系，其中leader副本负责处理读写请求，follower副本只负责与leader副本的消息同步。副本处于不同的broker中，当leader副本出现故障时，从follower副本中重新选举新的leader副本对外提供服务。**kafka通过多副本机制实现了故障的自动转移**，当kafka集群中某个broker失效时仍然能保证服务可用。


kafka消费端也具有一定的容灾能力。consumer使用pull模式从服务端拉取消息，并且保存消费的具体位置，当消费者宕机后恢复上线时可以根据之前保存的消费位置重新拉取需要的消息进行消费，这样就不会造成消息丢失。

分区中的所有副本统称为AR(Assigned Replicas)。所有与leader副本保持一定程度同步的副本(包括leader副本在内)组成ISR(In-Sync Replicas)，ISR集合是AR集合中的一个子集。消息就先发送到leader副本，然后follower副本才能从leader副本中拉取消息进行同步，同步期间内follower副本相对于leader副本而言会有一定程度的滞后。

前面所说的"一定程度的同步"是指可忍受的滞后范围，这个范围可以通过参数进行配置。与leader副本同步滞后过多的副本(不包括leader副本)组成OSR(Out-of-Sync-Replicas)，由此可见，AR=ISR+OSR。在正常情况下，所有的follower副本都应该与leader副本保持一定程度的同步，即AR=ISR,OSR集合为空。


leader副本负责维护和跟踪ISR集合中的所有follower副本的之后状态，当follower副本落后太多或失效时,leader副本会把它从ISR集合中剔除。如果OSR集合中有folower副本追上了leader副本，那么leader副本会把它从OSR集合转移至ISR集合。默认情况下，当leader副本发生故障时，只有在ISR集合中的副本才有资格被选举为新的leader，而在OSR集合中的副本没有任何机会(这种原则可以修改响应的参数配置来改变)




ISR 与 HW 和 LEO 也有紧密的关系。HW 是 High Watermark 的缩写，俗称高水位，它标识了一个特定的消息偏移量（offset），消费者只能拉取到这个 offset 之前的消息。


LEO 是 Log End Offset 的缩写，它标识当前日志文件中下一条待写入消息的 offset，上图中 offset 为9的位置即为当前日志文件的 LEO，LEO 的大小相当于当前日志分区中最后一条消息的 offset 值加1。分区 ISR 集合中的每个副本都会维护自身的 LEO，而 ISR 集合中最小的 LEO 即为分区的 HW，对消费者而言只能消费 HW 之前的消息。


Kafka 的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的 follower 副本都复制完，这条消息才会被确认为已成功提交，这种复制方式极大地影响了性能。而在异步复制方式下，follower 副本异步地从 leader 副本中复制数据，数据只要被 leader 副本写入就被认为已经成功提交。在这种情况下，如果 follower 副本都还没有复制完而落后于 leader 副本，突然 leader 副本宕机，则会造成数据丢失。Kafka 使用的这种 ISR 的方式则有效地权衡了数据可靠性和性能之间的关系。 


注意:传统的同步复制是指让所有副本，也就是ISR和OSR都需要接收到producer传递的消息才算接收成功(leader需要分发给全部副本)，传统的异步复制，是指只需要当前的leader副本接收到producer传递到的消息。设置ISR的原因就是中和这两点因素，异步复制会导致leader故障后部分消息就丢失了，而同步复制因为需要AR全部同步消息才算接收成功，太消耗性能，那就采取折中的方案，OSR因为消息同步落后太多了，并且不会参与zookeeper的选举机制，那么我就只需要让ISR接收到消息就算接收成功，减少了需要进行消息同步的副本数同时保证了数据多副本来防止数据丢失同时提高性能
