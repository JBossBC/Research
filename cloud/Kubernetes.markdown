# Kubernetes

kubernetes是谷歌十几年来大规模容器技术应用的重要成果。基于容器技术来实现资源管理的自动化，以及跨多个数据中心的资源利用率的最大化。kubernetes也是一个全新的基于容器技术的分布式架构领先方案，是容器云的优秀平台选型方案，已成为新一代的基于容器技术的PaaS平台的重要底层框架，也是云原生技术生态圈的核心，服务网格、无服务器架构等新一代分布式架构框架及技术纷纷基于kubernetes实现。

kubernetes是一个完备的分布式系统支撑平台。kubernetes具有完备的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建的智能负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制，以及多粒度的资源配额管理能力。同时，kubernetes提供了完善的管理工具，这些工具涵盖了包括开发、部署测试、运维监控在内的各个环节。


在kubernetes中，Service是分布式集群架构的核心。一个Service对象拥有如下关键特征。

+ 拥有唯一指定的名称
+ 拥有一个虚拟IP地址和端口号
+ 能够提供某种远程服务能力
+ 能够将客户端对服务的访问请求转发到一组容器应用上。


Service的服务进程通常基于Socket通信方式对外提供服务，比如Redis、Memcached、Mysql、web Server，或者是实现了某个具体业务的特定TCP Server进程。虽然一个Service通常由多个相关的服务进程提供服务，每个服务进程都有一个独立的Endpoint(IP+Port)访问点，但Kubernetes能够让我们通过Service(ClusterIP+Service Port)连接指定的服务。有了kubernetes内建的透明负载均衡和故障恢复机制，不管后端有多少个具体的服务进程，也不管某个服务进程是否由于发生故障而被重新部署到其他机器，都不会影响对服务的正常调用。更重要的是，这个Service本身一旦创建就不再变化，这意味着我们再也不用为kubernetes集群中应用服务进程IP地址变来变去的问题头疼了。

容器提供了强大的隔离功能，所以我们有必要把为Service提供服务的这组进程放入容器中进行隔离。为此，kubernetes设计了pod对象，将每个服务进程都包装到相应的pod中，使其成为在pod中运行的一个容器。为了建立Service和Pod间的关联关系，kubernetes首先给每个pod都贴上一个标签(Label)，比如给运行的Mysql的Pod贴上name=mysql，给运行PHP的Pod贴上name=php标签，然后给相应的Service定义标签选择器(Label Selector)，例如Mysql Service的标签选择器的选择条件为name=mysql，意为该Service要作用于所有包含name=mysql标签的Pod。这样一来，就巧妙解决了Service与Pod的关联问题。

首先Pod运行在一个被称为节点的环境中，这个节点既可以是物理机，也可以是私有云或者公有云中的一个虚拟机，在一个节点上能够运行多个Pod;其次，在每个Pod中都运行着一个特殊的被称为Pause的容器，其他容器则为业务容器，这些业务容器共享Pause容器的网络栈和Volume挂载卷，因此它们之间的通信和数据交换更为高效，在设计时我们可以充分利用这一特定将一组密切相关的服务进程放入同一个Pod中;最后，需要注意的是，并不是每个Pod和它里面运行的容器都能被映射到一个Service上，只有提供服务(无论是对内还是对外)的那组Pod才会被映射为一个服务。

在集群管理方面，kubernetes将集群中的机器划分为一个Master和一些Node。在Master上运行着集群管理相关的一些进程:kube-apiserver、kube-controller-manager和kube-scheduler，这些进程实现了整个集群的资源管理、Pod调度、弹性伸缩、安全控制、系统监控和纠错等管理功能，并且都是自动完成的。Node作为集群中的工作节点，其上面运行着真正的应用程序。在Node上，Kubernetes管理的最小运行单元是Pod。在Node上运行着Kubernetes的kubelet、kube-proxy服务进程，这些服务进程负责pod的创建、启动、监控、重启、销毁，以及实现软件模式的负载均衡器。

传统的IT系统中服务扩容和服务升级这两个难题，以及kubernetes所提供的全新解决思路。服务的扩容涉及资源分配(选择哪个节点进行扩容)、实例部署和启动等环节。在一个复杂的业务系统中，这两个难题基本上要靠人工一步步操作才能得以解决，费时费力又难以保证实施质量。

在kubernetes集群中，只需为需要扩容的Service关联的Pod创建一个Deployment对象，服务扩容以至服务升级等问题就解决了。在一个Deployment定义文件中包括以下3个关键信息。

+ 目标Pod的定义
+ 目标Pod需要运行的副本数量(Replicas)
+ 要监控的目标Pod的标签

在创建好Deployment之后，kubernetes会根据这一定义创建符合要求的Pod，并且通过在Deployment中定义的Label筛选出对应的Pod实例并实时监控其状态和数量。如果实例数量少于定义的副本数量，则会根据在Deployment对象中定义的pod模板创建一个新的pod，然后将此pod调度到合适的Node上启动运行，直到Pod实例的数量达到预定目标。这个过程完全是自动化的，无须人工干预。有了Deployment，服务扩容就变成了一个纯粹的简单数字游戏了，只需要修改Deployment中的副本数量即可。后续的服务升级也将通过修改Deployment来自动完成。


