# Distributed Transactions


分布式事务从实质上看与数据库事务的概念是一致的，既然是事务也就需要满足事务的基本特性(ACID),只是分布式事务相对于本地事务而言其表现形式有很大的不同。在一个JVM进程中如果需要同时操作数据库的多条记录，而这些操作需要在一个事务中，那么我们可以通过数据库提供的事务机制(一般是数据库锁)来实现。


而随着这个JVM进程被拆分成了微服务架构，原本一个本地逻辑执行单元被拆分到了多个独立的微服务中，这些微服务又分别操作不同的数据库和表，服务之间通过网络调用。


分布式事务是为了解决微服务架构(形式都是分布式系统)中不同节点之间的数据一致性问题。这个一致性问题本质上解决的也是传统事务需要解决的问题，即一个请求在多个微服务调用链中，所有服务的数据处理要么全部成功，要么全部回滚。当然分布式事务问题的形式可能与传统事务会有比较大的差异，但是问题本质上是一致的，都是要求解决数据的一致性问题。

在分布式事务的发起方在向分布式事务协调者发送请求时，协调者首先会分别向参与者节点A、参与这节点的节点B分别发送事务预处理请求，称为prepare,说直白点就是问一下这些参与节点"这件事你们能不能处理成功了",此时这些参与者节点一般来说就会打开本地数据库事务，然后开始执行数据库本地事务，但在执行完成后并不会立马提交数据库本地事务，而是先向协调者报告说:"我这边可以处理了/我这边不能处理"


如果所有的参与者节点都向协调者作了"vote commit"的反馈的话,那么此时流程就会进入第二个阶段。

如果所有参与者节点都向协调者报告:"我这边可以处理",那么此时协调者就会向所有参与者节点发送"**全局提交确认通知**",即你们都可以进行本地事务提交了，此时参与者节点就会完成自身本地数据库事务的提交,并将最终提交结果回复"ack"给协调者，然后协调者就会向调用方返回分布式事务处理完成的结果

在第二阶段除了所有的参与者节点都反馈“我这边可以处理了”的情况外，也会有节点反馈说“我这边不能处理”的情况发生，此时参与者节点就会向协调者节点反馈“Vote_Abort”的消息。此时分布式事务协调者节点就会向所有的参与者节点发起事务回滚的消息（“global_rollback”），此时各个参与者节点就会回滚本地事务，释放资源，并且向协调者节点发送“ack”确认消息，协调者节点就会向调用方返回分布式事务处理失败的结果。