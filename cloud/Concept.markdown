# Concept


### 传统部署时代

早期，各个组织是在物理服务器上运行应用程序。由于无法限制在物理服务器中运行的应用程序资源使用，因此会导致资源分配问题。例如，如果在同一台物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况，而导致其他应用程序资源的性能下降。一种解决方案是将每个应用程序都运行在不同的物理服务器上，但是当某个应用程序资源利用率不高时，剩余资源无法被分配给其他应用程序，而且维护许多物理服务器的成本很高

### 虚拟化部署时代

因此，虚拟化技术被引入了。虚拟化技术允许你在单个物理服务器的CPU上运行多台虚拟机。虚拟化能使应用程序在不同VM之间被彼此隔离，且能提供一定程度的安全性，因为一个应用程序的信息不能被另一个应用程序随意访问。

虚拟化技术能够更好地利用物理服务器的资源，并且因为可轻松地添加或更新应用程序，而因此具有更高的可扩缩性，以及降低硬件成本等等好处。通过虚拟化，你可以将一组物理资源呈现为可丢弃地虚拟机集群。

每个VM是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。


### 容器部署时代


容器类似于VM，但是更宽松的隔离特性，使容器之间可以共享操作系统。因此，容器比VM被认为是更轻量级的。且与VM类似，每个容器都有自己的文件系统、CPU、内存、进程空间等。由于它们与基础架构分离，因此可以跨云和OS发行版本进行移植。

容器具有许多优势:
+ 敏捷应用程序的创建和部署:与使用VM镜像相比，提高了容器镜像创建的简便性和效率。
+ 持续开发、集成和部署:通过快速简单的回滚,提供可靠且频繁的容器镜像构建和部署
+ 关注开发与运维的分离:在构建、发布时创建应用程序容器镜像，而不是在部署时，从而将应用程序与基础架构分离。
+ 可观察性:不仅可以显示OS级别的信息和指标，还可以显示应用程序的运行状况和其他指标信息。
+ 跨开发、测试和生产的环境一致性:在笔记本计算机上也可以和在云中运行一样的应用程序
+ 跨云和操作系统发行版本的可移植性:可在ubuntu、RHEL、CoreOS、本地、Google kubernetes Engine和其他任何地方运行。
+ 以应用程序为中心的管理:提高抽象级别，从在虚拟硬件上运行OS到使用逻辑资源在OS上运行应用程序
+ 松散耦合、分布式、弹性、解放的微服务:应用程序被分解成较小的独立部分，并且可以动态部署和管理-而不是在一台大型单机上整体运行。
+ 资源隔离:可预测的应用程序性能
+ 资源利用:高效率和高密度

## 为什么需要kubernetes，它能做什么?

容器是打包和运行应用程序的好方式。在生产环境中，你需要管理运行着应用程序的容器，并确保服务不会下线。例如，如果一个容器发生故障，则你需要启动另一个容器。如果此行为交给系统处理，是不是会更容易一些?

kubernetes为你提供了一个可弹性运行分布式系统的框架。kubernetes会满足你的扩展要求、故障转移你的应用、提供部署模式。


+ 服务发现和负载均衡

    kubernetes可以使用DNS名称或自己的IP地址来暴露容器。如果进入容器的流量很大，kubernetes可以负载均衡并分配网络流量，从而使部署稳定。

+ 存储编排

    kubernetes允许你自动挂载你选择的存储系统，例如本地存储、公共云云提供商等。

+ 自动部署和回滚

     你可以使用kubernetes描述已部署容器所需状态，它可以以受控的速率将实际状态更改为期望状态。例如，你可以自动化kubernetes来为你的部署创建信容器，删除现有容器并将它们的所有资源用于新容器。

+ 自动完成装箱计算

     你为kuberntes提供许多节点组成的集群，在这个集群上运行容器化的任务。你告诉kubernetes每个容器需要多少CPU和内存。kubernetes可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。


+ 自我修复

     kubernetes将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。

+ 密钥与配置管理

     kubernetes允许你存储和管理敏感信息，例如密码、OAuth令牌和ssh密钥。你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥

