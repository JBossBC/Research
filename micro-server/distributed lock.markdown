# 分布式锁

分布式锁，即分布式系统中的锁。在单体应用中我们通过锁解决的是控制共享资源访问的问题，而分布式锁，就是解决了分布式系统中控制共享资源访问的问题。**与单体应用不同的是，分布式系统中竞争的最小粒度从线程升级到了进程**


## 分布式锁应该具备哪些条件

+ 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行。
+ 高可用的获取锁与释放锁
+ 高性能的获取锁与释放锁
+ 具备可重入特性(可以理解为重新进入，由多于一个任务并发使用，而不必担心数据错误)
+ 具备锁失效机制，即自动解锁，防止死锁。
+ 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败


###  分布式锁的实现方式:

+ 基于数据库实现分布式锁
+ 基于zookeeper实现分布式锁
+ 基于redis实现分布式锁



## 基于数据库的分布式锁

1. 基于数据库表的增删

+ 首先创建一张锁表，包含类的全路径名+方法名，时间戳等字段
+ 当锁住某个方法时，往该表中插入一条相关的记录。类的全路径名+方法名是有唯一性约束的，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，执行完毕后，delete该记录

2. 基于数据库自身的排他锁???

在查询语句中增加for update

> 基于数据库锁的优缺点

> 两种方式都是依赖数据库表，一种是通过表中的记录判断当前是否有锁存在，另一种是通过数据库的排他锁来实现分布式锁

> 优点:直接借助数据库，简单容易理解

> 缺点:操作数据库需要一定的开销，性能问题需要考虑


## 基于zookeeper的分布式锁


基于zookeeper临时有序节点可以实现的分布式锁。每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁时，只需要将这个瞬时节点删除即可。同时，其可避免服务宕机导致的锁无法释放，而产生的死锁问题。

zookeeper实现的分布式锁存在两个缺点:

+ 性能上没有缓存服务那么高，因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过leader服务器来执行，然后将数据同步到所有follower机器上。
+ zookeeper的并发安全性问题，因为存在网络抖动，客户端和zk集群的session断了，zk集群以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。


## 基于redis的分布式锁


redis命令:

(1)  setnx:set if not exists，仅当key不存在时，将key的值设为value。若设定的key已经存在，则setnx不做任何动作。

+ 返回1,说明该进程获得锁，将key的值设为value
+ 返回0，说明其他进程已经获得了锁，进程不能进入临界区。

(2)  get:获取key的值，如果存在则返回，如果不存在，则返回nil

(3) getset:该方法是原子的，对key设置newValue这个值，并且返回原来的旧值

(4) del:删除redis指定的key


### **基于set命令的分布式锁**

+ 使用setnx进行加锁，当返回1时，说明成功获取锁
+ 当执行完后，使用del释放锁。


>（1）存在的问题：假设线程获取了锁之后，在执行任务的过程中挂掉，来不及显示地执行del命令释放锁，那么竞争该锁的线程都会执行不了，产生死锁的情况。

> （2）解决方案：设置锁超时时间


+ 设置锁超时时间，setnx的key必须设置一个超时时间，以保证即便没有被显示释放，这把锁也要在一定时间后自动释放，可以使用expire设置锁超时时间。

> （1）存在问题：

> setnx 和 expire 不是原子性的操作，假设某个线程执行setnx 命令，成功获得了锁，但是还没来得及执行expire 命令，服务器就挂掉了，这样一来，这把锁就没有设置过期时间了，变成了死锁，别的线程再也没有办法获得锁了。

>（2）解决方案：redis的set命令支持在获取锁的同时设置key的过期时间

+ 使用set命令加锁并设置锁过期时间(set key value nx ex expiretime)

> 存在问题:如果A获得了锁，设置了超时时间为30秒，如果某些原因导致A执行很慢，过了30秒还没执行完，这时候锁自动释放，B获得了锁，然后A执行完后，执行del来释放锁，这时候B还没有执行完，A实际上删除的是B加的锁





 + 判断是否为自己的锁:del之前做一个判断，验证是否是自己的锁，在加锁的时候把唯一ID当作value，并在删除之前验证key对应的value是不是自己的ID。但是这样又有一个新的问题，get操作，判断释放锁的操作不是原子性的，**对于非原子性问题，我们可以使用lua脚本来确保操作的原子性**????????有什么问题
 + 锁续期:我们可以让获取锁的进程开启一个守护线程来续期

> ① 假设线程A执行了29 秒后还没执行完，这时候守护线程会执行 expire 指令，为这把锁续期 20 秒。守护线程从第 29 秒开始执行，每 20 秒执行一次。

> ② 情况一：当线程A执行完任务，会显式关掉守护线程。

> ③ 情况二：如果服务器忽然断电，由于线程 A 和守护线程在同一个进程，守护线程也会停下。这把锁到了超时的时候，没人给它续命，也就自动释放了。


### **基于setnx，get，getset的分布式锁**


1. setnx(key,当前时间+过期超时时间)，如果返回1，则获取成功，如果返回0则没有获取到锁,转向步骤2
2. get(key)获取值的oldExpireTime,并将这个value与当前系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向步骤3
3. 计算新的过期时间newExpireTime=当前时间+锁超时时间，然后getset(key,newExpireTime)会返回当前lockkey的值currentExpireTime
4. 判断currentExpireTime与oldExpireTime是否相等，如果相等，则说明getset设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。
5. 在获取到锁之后，当前线程可以开始自己的业务处理。当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行del释放，如果大于，则不需要对锁再处理。

存在问题：

（1）这个锁的核心是基于System.currentTimeMillis()，如果多台服务器时间不一致，那么问题就出现了，但是这个bug完全可以从服务器运维层面规避的，而且如果服务器时间不一样的话，只要和时间相关的逻辑都是会出问题的

（2）如果前一个锁超时的时候，刚好有多台服务器去请求获取锁，那么就会出现同时执行redis.getset()而导致出现过期时间覆盖问题，不过这种情况并不会对正确结果造成影响

（3）存在多个线程同时持有锁的情况：如果线程A执行任务的时间超过锁的过期时间，这时另一个线程就可以获得这个锁了，造成多个线程同时持有锁的情况。类似于方案一，可以使用“锁续期”的方式来解决。

### 前两种redis分布式锁的存在的问题

前面两种redis分布式锁的实现方式，如果从“高可用”的层面来看，仍然是有所欠缺，也就是说当 redis 是单点的情况下，当发生故障时，则整个业务的分布式锁都将无法使用。

为了提高可用性，我们可以使用主从模式或者哨兵模式，但在这种情况下仍然存在问题，在主从模式或者哨兵模式下，正常情况下，如果加锁成功了，那么master节点会异步复制给对应的slave节点。但是如果在这个过程中发生master节点宕机，主备切换，slave节点从变为了 master节点，而锁还没从旧master节点同步过来，这就发生了锁丢失，会导致多个客户端可以同时持有同一把锁的问题。



那么，如何避免这种情况呢？redis 官方给出了基于多个 redis 集群部署的高可用分布式锁解决方案：RedLock，在方案三我们就来详细介绍一下。（备注：如果master节点宕机期间，可以容忍多个客户端同时持有锁，那么就不需要redLock）


### **基于redlock的分布式锁**


Redlock算法是Redis的作者 Antirez 在单Redis节点基础上引入的高可用模式。**Redlock的加锁要结合单节点分布式锁算法共同实现，因为​​​它是RedLock的基础**

现在假设有5个Redis主节点(大于3的奇数个)，这样基本保证他们不会同时都宕掉，获取锁和释放锁的过程中，客户端会执行以下操作：

1. 获取当前unix时间，以毫秒为单位，并设置超时时间TTL
2. 依次尝试从5个实例，使用相同的key和具有唯一性的value获取锁，当向redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间TTL，这样可以避免客户端死等。比如：TTL为5s，设置获取锁最多用1s，所以如果一秒内无法获取锁，就放弃获取这个锁，从而尝试获取下个锁
3. 客户端 获取所有能获取的锁后的时间 减去 第(1)步的时间，就得到锁的获取时间。锁的获取时间要小于锁失效时间TTL，并且至少从半数以上的Redis节点取到锁，才算获取成功锁。
4. 如果成功获取锁，key的真正有效时间=TTL-锁的获取时间-时钟漂移
5. 如果某些原因，获取锁失败(没有在半数以上的实例获取到锁或者取锁时间已经超过了有效时间),客户端应该在所有的redis实例上进行解锁,无论redis实例是否加锁成功，因为可能服务端响应消息丢失了但是实际成功了。
6. 失败重试，当client不能获取锁时，应该在实际时间后重试获取锁，同时重试获取锁要有一定限制(自旋),不然可能会导致一定时间内的活锁。

### redlock性能及崩溃恢复

redlock保证了基于redis的分布式锁的可用性，如果有节点发生崩溃重启，对锁的安全性影响基于redis持久化配置:

+ 如果redis没有持久化,在clientA获取锁成功后，所有redis重启，clientb在这个时间段也能获取锁，违反了锁的排他互斥性。
+ 如果启动AOF永久化存储，因为AOF基于增量复制的，如果同步磁盘方式位always,那么可能会导致性能急剧下降，但是可以保证锁的安全性,这样看来，这种方式使用redis持久化来进行崩溃恢复与性能互斥。
+ 为了有效解决既保证锁完全有效性和性能高校问题:antirez提出了延迟重启的概念，redis同步到磁盘的方式默认是每秒一次，在redis崩溃单机后，先不立即重启它，而是等待TTL事件后在重启，那么这个节点在重启之前参与的所有锁都会过期，他在重启后就不会对之前已有的锁造成影响，缺点就是TTL时间内服务相当于不可用。









