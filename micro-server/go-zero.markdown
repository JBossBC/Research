# go-zero 自带中间件解析

go-zero 天生提供一系列中间件供开发人员使用，包括鉴权、日志记录、异常捕获、监控报警、数据统计、并发控制、链路追踪、超时控制、自动熔断、自动降载，在服务器启动前统一加载到各个handler里面。

在go-zero源码中我们可以看到相关的中间件handler

+ authhandler -> 鉴权
+ breakerhandler - > 自动熔断
+ loghandler -> 日志记录
+ maxbyteshandler -> 最大请求字节数
+ metrichandler -> 数据统计
+ recoverhandler ->异常捕获
+ timeouthandler -> 超时控制
+ tracinghandler -> 链路追踪
+ prometheushandler -> 监控报警
+ sheddinghandler -> 自动降载
+ maxconnshandler -> 最大连接数控制
+ gunziphandler ->   zip压缩


.............

## 自动熔断:

由于网络问题或者服务故障，熔断器及时做出向服务调用方返回一个符合预期的，可处理的降级响应，而不是用户长时间的等待或者抛出无法处理的异常，这样保证了服务提供方不会对系统资源长时间的，不必要的占用，避免故障在系统中蔓延，防止雪崩效应的产生。

+ 熔断关闭状态:当服务访问正常时，熔断器处于关闭状态，服务调用方可以正常地对服务进行调用
+ 熔断开启状态:默认情况下，在固定时间内接口调用出错比例达到一个阈值，熔断器会进入熔断开启状态，进入熔断状态后，后续对该服务的调用都会被切断，熔断器会执行本地的降级方法。
+ 半熔断状态:在熔断状态开启一段时间之后，熔断器会进入半熔断状态，在半熔断状态下，熔断器会尝试恢复服务调用方对服务的调用，允许部分请求调用该服务，并监控其调用成功率，如果成功率达到预期，则说明服务已恢复正常，熔断器进入关闭状态。


在go-zero里面的brokerhandler实现用了google的一套熔断器，大概流程如下(根据 brokerhandler进行解析)

+ 首先当然还是注册broker中间件(服务启动的时候注册)
+ 请求过来的时候首先会broker.allow()判断是否熔断，如果被熔断将会返回ErrServiceUnavailable错误,此错误将在下面进行捕获,捕获之后直接返回response（服务不可获得)并做metrics记录，如果没有被熔断，则进入服务处理阶段，当然会设置一个defer用来判断处理结果，如果处理结果的code 小于 500，则会直接通过，否则会记录为一次服务不可用。


## 自动降载 

在微服务体系中，调用链路错综复杂，作为服务提供者需要有一种保护自己的机制，防止调用方无脑调用压垮自己，保证自身服务的高可用。

最常见的保护机制就是限流，使用限流器的前提是必须要知道自身能够处理的最大并发数，一般在上线前通过压测来得到最大并发数，而且日常请求中每个接口的限流机制都不一样，同时系统一直在不断的更迭其处理能力往往也会随之变化，每次上线前都需要进行压测然后调整限流参数变得非常繁琐。

### 自适应降载

根据服务自身的系统负载判断是否需要降载。


+ 设计目标

     1. 保证服务不被拖垮
     2. 在系统稳定的前提下，保持系统的吞吐量、


+ 判断高负载的两个指标

      1. cpu是否过载
      2. 最大并发数是否过载

同时满足以上两种情况则说明服务处于高负载状态，需要进行自适应降载

同时需要注意高并发场景cpu负载，并发数往往波动较大，我们称这种现象为毛刺。毛刺现象可能会导致系统一直在频繁的进行自动降载操作，所以**我们一般获取一段时间内的指标均值来使指标更加平滑，但是需要占用一定的系统资源**


实现主要有三类属性

+ cpu负载阈值:超过此值的cpu处于高负载状态
+ 冷却器:假如服务之前被降载过，那么将进入冷却器，目的在于防止降载过程中负载还没完全降下来立马加压导致来回抖动。因为降低负载需要一定的时间，处于冷却器内应该继续检查并发数是否超过限制，超过限制，超过限制则继续丢弃请求。
+ 并发数:当前正在处理的并发数，当前正在梳理的并发平均数，以及最近一段时间内的请求数与响应时间，目的是为了计算当前正在处理的并发数是否大于系统可承载的最大并发数。