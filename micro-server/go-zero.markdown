# go-zero 自带中间件解析

go-zero 天生提供一系列中间件供开发人员使用，包括鉴权、日志记录、异常捕获、监控报警、数据统计、并发控制、链路追踪、超时控制、自动熔断、自动降载，在服务器启动前统一加载到各个handler里面。

在go-zero源码中我们可以看到相关的中间件handler

+ authhandler -> 鉴权
+ breakerhandler - > 自动熔断
+ loghandler -> 日志记录
+ maxbyteshandler -> 最大请求字节数
+ metrichandler -> 数据统计
+ recoverhandler ->异常捕获
+ timeouthandler -> 超时控制
+ tracinghandler -> 链路追踪
+ prometheushandler -> 监控报警
+ sheddinghandler -> 自动降载
+ maxconnshandler -> 最大连接数控制
+ gunziphandler ->   zip压缩


.............

## 自动熔断:

由于网络问题或者服务故障，熔断器及时做出向服务调用方返回一个符合预期的，可处理的降级响应，而不是用户长时间的等待或者抛出无法处理的异常，这样保证了服务提供方不会对系统资源长时间的，不必要的占用，避免故障在系统中蔓延，防止雪崩效应的产生。

+ 熔断关闭状态:当服务访问正常时，熔断器处于关闭状态，服务调用方可以正常地对服务进行调用
+ 熔断开启状态:默认情况下，在固定时间内接口调用出错比例达到一个阈值，熔断器会进入熔断开启状态，进入熔断状态后，后续对该服务的调用都会被切断，熔断器会执行本地的降级方法。
+ 半熔断状态:在熔断状态开启一段时间之后，熔断器会进入半熔断状态，在半熔断状态下，熔断器会尝试恢复服务调用方对服务的调用，允许部分请求调用该服务，并监控其调用成功率，如果成功率达到预期，则说明服务已恢复正常，熔断器进入关闭状态。


在go-zero里面的brokerhandler实现用了google的一套熔断器，大概流程如下(根据 brokerhandler进行解析)

+ 首先当然还是注册broker中间件(服务启动的时候注册)
+ 请求过来的时候首先会broker.allow()判断是否熔断，如果被熔断将会返回ErrServiceUnavailable错误,此错误将在下面进行捕获,捕获之后直接返回response（服务不可获得)并做metrics记录，如果没有被熔断，则进入服务处理阶段，当然会设置一个defer用来判断处理结果，如果处理结果的code 小于 500，则会直接通过，否则会记录为一次服务不可用。


## 自动降载 

在微服务体系中，调用链路错综复杂，作为服务提供者需要有一种保护自己的机制，防止调用方无脑调用压垮自己，保证自身服务的高可用。

最常见的保护机制就是限流，使用限流器的前提是必须要知道自身能够处理的最大并发数，一般在上线前通过压测来得到最大并发数，而且日常请求中每个接口的限流机制都不一样，同时系统一直在不断的更迭其处理能力往往也会随之变化，每次上线前都需要进行压测然后调整限流参数变得非常繁琐。

### 自适应降载

根据服务自身的系统负载判断是否需要降载。


+ 设计目标

     1. 保证服务不被拖垮
     2. 在系统稳定的前提下，保持系统的吞吐量、


+ 判断高负载的两个指标

      1. cpu是否过载
      2. 最大并发数是否过载

同时满足以上两种情况则说明服务处于高负载状态，需要进行自适应降载

同时需要注意高并发场景cpu负载，并发数往往波动较大，我们称这种现象为毛刺。毛刺现象可能会导致系统一直在频繁的进行自动降载操作，所以**我们一般获取一段时间内的指标均值来使指标更加平滑，但是需要占用一定的系统资源**


实现主要有三类属性

+ cpu负载阈值:超过此值的cpu处于高负载状态
+ 冷却器:假如服务之前被降载过，那么将进入冷却器，目的在于防止降载过程中负载还没完全降下来立马加压导致来回抖动。因为降低负载需要一定的时间，处于冷却器内应该继续检查并发数是否超过限制，超过限制，超过限制则继续丢弃请求。
+ 并发数:当前正在处理的并发数，当前正在梳理的并发平均数，以及最近一段时间内的请求数与响应时间，目的是为了计算当前正在处理的并发数是否大于系统可承载的最大并发数。



go-zero的自动降载的实现和自动熔断机制类似，先通过CPU负载，并发数，等判断是否处于降载期间，如果处于则进行拦截，否则进行放行。


     	// A SheddingStat is used to store the statistics for load shedding.
	SheddingStat struct {
		name  string
		total int64
		pass  int64
		drop  int64
	}


## 超时控制


我的理解为:我们需要对用户的体验负责，不可否认的是，自动熔断和自动降载有效地提高了微服务之间的服务可靠性，但自动熔断和自动降载是建立在系统承载过高，或者是服务响应成功率不高，但对于一些其他的情况并没有进行处理，比如说:高负载情况下对数据库的查询可能会极大的增加响应时间，这个时候为了对用户的体验负责，同时满足测试军规2-5-10，建立一个优秀的系统，我们必须及时给用户反应操作的结果，才能极大地满足用户地使用。



go-zero里面的超时控制实现极具代表性，根据源码可以知道主要步骤如下:

+ 判断是否为websocket连接，如果是则对此次请求不使用超时控制
+ 创建一个 context注入超时时间
+ **精髓所在:启动golang协程，设置defer方法捕获异常，同时向panicchan管道内写入,然后再向下传递执行下一个handler,最后关闭正常done管道**(此时我们应该还注意一下他对responseWrite进行了封装,这一层其实很有意思，在注册的这些中间件来说，或者对于全局中间件来说，超时控制这一块其实在select上面注定了他是response返回给用户的最后一关,他先给responseWrite进行了封装，后续操作将使用缓冲流来提高流处理速度，最后再写入实际的responseWrite,这点处理非常优雅)
+ 接下来他使用select接收三种通道的值,第一个panicChan,这个就不用多说，捕获业务处理异常直接panic,第二种接收done通道的值，从源码来看，对于done的处理就两个，第一个是初始化，第二个是close(done),也就是说这一步骤是用来处理正常流程下的业务操作结果;最后一个，也就是超时控制的核心所在，接收上述注册的context的done值,这一点是超时处理后应该进入的步骤。(**最后一个细节的地方就是，他把tw的操作再最后的时候都加锁，这个地方目前来说我没有找到使用的必要**)





