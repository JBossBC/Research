# Link Tracking


在分布式、微服务架构下，应用一个请求往往贯穿多个分布式服务，这给应用的故障排查、性能优化带来新的挑战。**分布式链路追踪作为解决分布式应用可观测问题的重要技术**，愈发成为分布式应用不可或缺的基础设施。


在分布式架构下，当用户从浏览器客户端发起一个请求时，后端处理逻辑往往贯穿多个分布式服务，这回浮现很多问题，比如:

+ 请求整体耗时较长，具体慢在哪个服务？
+ 请求过程中出错了，具体是哪个服务出错？
+ 某个服务的请求量如何，接口成功率如何？

回答这些问题变得不是那么简单，我们不仅仅需要直到某一个服务的接口处理统计数据，还需要了解两个服务之间的接口调用依赖关系，**只有建立起整个请求在多个服务间的时空顺序**,才能更好地帮助我们理解和定位问题，而这，正是分布式链路追踪系统可以解决的

## 分布式链路追踪系统如何帮助我们

分布式链路追踪技术的核心思想:在用户一次分布式请求服务的调用过程中，将请求在所有子系统间的调用过程和时空关系追踪记录下来，还原成调用链路集中展示，信息包括各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。
![](https://img-blog.csdnimg.cn/img_convert/af3e0a420388d2d9e752e27a15525157.png)

如上图所示，通过分布式链路追踪构建出完整的请求链路后，可以很直观地看到请求耗时主要耗费在哪个服务环节，帮助我们更快聚焦问题。

同时，还可以对采集的链路数据做进一步的分析，从而可以建立整个系统各服务间的依赖关系、以及流量情况、帮助我们更好地排查系统的循环依赖、热点服务等问题

![](https://img-blog.csdnimg.cn/img_convert/1fe8ad15149df520671b258c738c6efd.png)


## 分布式链路追踪系统架构概览

在分布式链路追踪系统中，最核心地概念，便是链路追踪地数据模型定义，主要包括Trace和Span

![](https://img-blog.csdnimg.cn/img_convert/5af8bf7268f960844cca37a3c3836d7e.png)

其中，Trace是一个逻辑概念，表示一次分布式请求经过的所有局部操作(Span)构成的一条完整地有向无环图，其中所有的Span和TraceId相同。

Span则是真实的数据实体模型，表示一次分布式请求过程的一个步骤或操作，代表系统中一个逻辑运行单元,Span之间通过嵌套或者顺序排列建立因果关系。Span数据在采集端生成，之后上报到服务端，做进一步处理。其中包含如下关键属性:

+ Name:操作名称,如一个RPC方法的名称，一个函数名
+ StartTime/EndTime:起始时间和结束时间，操作的生命周期
+ ParentSpanId:父级Span的ID
+ Attributes:属性,一组<k,v>键值对构成的集合
+ Event:操作期间发生的时间
+ SpanContext:Span上下文内容，通常用于在Span间传播，其核心字段包括TraceId、SpanId



## OpenTracing

opentracing是一套分布式追踪协议，与平台，语言无关，统一接口，方便开发接入不同的分布式追踪系统。

+ 语义规范:描述定义的数据模型Tracer，span和spancontext等
+ 语义惯例:罗列出tag和logging操作时，标准的key值

### Trace和span

在opentracing中，跟踪信息被分为Trace和Span两个部分，它们按照一定的结构存储跟踪信息，所以它们是OpenTracing中数据模型的核心。

Trace是一次完整的跟踪，Trace由多个Span组成。( Trace 是多个 Span 组成的有向非循环图)


### Trace

在OpenTracing中，Trace是一个有向非循环图，意味着Trace必定有且只有一个起点。

这个起点会创建一个Trace对象，这个对象一开始初始化了Trace id和process,trace id是一个32个长度的字符串组成，它是一个时间戳，而process是起点进程所在主机的信息。

每个Span封装了如下状态:

+ 操作名称
+ 开始时间戳
+ 结束时间戳
+ 一组零或多个键值结构的span标签。键必须是字符串，值可以是字符串，布尔或数值类型
+ 一组零或多个span日志，其中每个都是一个键值映射并与一个时间戳配对。键必须是字符串，值可以是任何类型。并非所有的OpenTracing实现都必须支持每种值类型。
+ 一个SpanContext
+ 零或多个因果相关的span间的references

> 每个spanContext封装了如下状态:

>     + 任何需要跟跨进程span关联的，依赖于OpenTracing实现的状态
>     + 键值结构的跨进程的Baggage items（区别于 span tag，baggage 是全局范围，在 span 间保持传递，而tag 是 span 内部，不会被子 span 继承使用。）


### inject和extract操作

既然是分布式的追踪，肯定涉及到跨进程/机器的通讯，在进程间通过传递SpanContext来提供足够的信息建立span间的关系

在上游服务中，spancontext通过inject操作向carrier中注入tracing信息，传递后下游服务中通过extract从carrier中提取tracing数据