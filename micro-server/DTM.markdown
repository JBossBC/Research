# DTM

DTM是一款开源的分布式事务管理器,解决跨数据库、跨服务、跨语言栈更新数据的一致性问题。

通俗一点说,DTM提供跨服务事务能力，一组服务要么全部成功，要么全部回滚,避免只更新了一部分数据的一致性问题。



## DTM架构

整个DTM架构中，一共有三个角色

+ RM-资源管理器:RM是一个应用程序,负责管理全局事务中的本地事务,他通常会连接到一个数据库，负责相关数据的修改，提交，回滚，补偿等操作。
+ AP-应用程序:AP是一个应用服务，负责全局事务的编排，他会注册全局事务，注册子事务，**调用RM接口**。
+ TM-事务管理器:TM就是DTM服务，负责全局事务的管理，每个全局事务都注册到TM，每个事务分支也注册到TM。TM会协调所有的RM，将同一个全局事务的不同分支，全部提交或全部回滚。

### 跨语言特性

### 高可用

在这个架构中，TM不是单点，而是一个服务集群。集群由多个dtm实例进程构成，多个dtm实例访问同一个高可用数据库。

几乎所有的云厂商都会提供高可用的数据库，几乎所有要求业务高可用的公司内部，都会有高可用的数据库，因此将dtm对接到一个高可用数据库是毫无困难的。

在实际的生产部署中，DTM是多实例的，连接的共享存储是高可用的，因此不存在单点，从而提供了高可用的DTM服务。


### 多进程同时轮询

全局事务的运行过程中，可能出现各种网络错误，导致全局事务无法一次完成，需要定时重试。

DTM默认会在每个进程实例中，去轮询超时需要处理的全局任务。为了保证上面的高可用进程部署，一个超时任务不会被多个实例同时取出，dtm采用了类似乐观锁的机制，保证一个任务只会被一个dtm实例取出。

+ DB存储引擎： 采用update ... set owner=..., time=... where ... 这种方式，因为update的原子性，能够保证一条记录只被一个实例更新
+ Redis存储引擎： 采用lua脚本原子操作，保证一条记录只被一个实例取出

**当然极端情况下，还是有可能出现这个任务被两个进程取出，这个时候由于每个分支的结果是幂等的，所以最终不会影响结果的正确性。**



### 术语

DTM在分布式事务的理论与事件中，存在一些专业术语

+ 事务分支:我们把每个服务管理的全局事务组成部分，称为事务分支。
+ 分支操作:每个事务分支，在SAGA、XA、TCC等事务模式下，会有多个操作
+ 本地事务:转出事务分支中的正向操作，通常会开启一个事务，对余额进行扣减，我们将数据操作的这个事务，称为本地事务。
+ GID:全局事务ID，用于标记全局事务，必须唯一。该ID可以采用UUID生成，也可以采用业务上的ID。


### 接口协议

目前dtm只支持http和grpc协议，以及在这基础上的部分微服务协议。由于分布式事务涉及分布式协作，某些参与者可能出现暂时不可用或者返回500等异常情况是不可避免的。这些暂时不可用和500，与业务上的失败有非常大的区别


>接口错误与业务失败

> 例如前面的转出金额操作，如果遇见暂时不可用，或者500，此时不应当认为转账失败，而进行回滚。

> 有个dtm的用户，在未使用分布式事务的旧系统中，曾经遇到过这类事故，起因是开发人员在调用发红包后，因为调用超时，认为发红包失败，没有扣减用户的余额，但是当红包服务恢复正常后，发现红包已发出，这就导致了金额错误，造成了事故。

因此进行分布式事务开发时，切记 接口返回错误 不等于 业务失败



dtm系统中，调用分支事务的服务，有四种结果：

+ SUCCESS: 表示成功
+ FAILURE: 表示失败，这个失败是指确定的失败结果，不需要重试。例如子事务因转账余额不足而失败，dtm服务因为事务已完成不允许再次提交等
+ ONGOING: 表示未完成，还在正常进行中，此时dtm服务器需要采用固定间隔重试，而不是指数退避算法重试
+ **其他: 表示临时错误，采用指数退避算法重试，避免出现故障或者bug，导致大量重试，导致负载过高**


> ONGOING

> DTM 引入了一个特殊的结果 ONGOING，当 DTM 收到这个返回值时，认为这个子事务操作还在正常进行中，还未完成，需要进行重试。假如你需要预定旅游出行的机票，第三方可能需要1个小时才能够确认机票预定的结果，那么应用可以指定分布式事务的重试间隔时间，并在未获得确定结果时，返回 ONGOING，这样 DTM 会按照固定间隔时间重试。

对于HTTP和GRPC中，如何明确表示三种结果


1. HTTP

     SUCCESS: 状态码 200 StatusOK
     
     FAILURE: 状态码 409 StatusConflict

     ONGOING: 状态码 425 StatusTooEarly

2. gRPC

     SUCCESS: 状态码 OK

     FAILURE: 状态码 Aborted

     ONGOING: 状态码 FailedPrecondition

## 二阶段消息


二阶段消息是dtm首创的事务模式，用于替换本地事务表和事务消息这两种现有方案。它能够保证本地事务的提交和全局事务提交是原子的，是和解决不需要回滚的分布式事务场景。











## 异常与子事务屏障

分布式事务之所以难，主要是因为分布式系统中各个节点都可能发生各种非预期的情况。

### NPC的挑战

分布式系统的最大敌人就是NPC了，在这里它是Network Delay,Process Pause,Clock Drift的首字母缩写

+ Network Delay,网络延迟。虽然网络在多数情况下工作的还可以，虽然TCP保证传输顺序和不会丢失，但它无法消除网络延迟问题。
+ Process Pause，进程暂停。有很多种原因可以导致进程暂停:比如编程语言中的GC会STW,以及云服务器迁移。
+ Clock Drift,时钟漂移。现实生活中我们通常认为时间是平稳流逝，单调递增的，但在计算机中不是。计算机使用时钟硬件记时间，通常是石英钟，记时精度有限，同时受机器温度影响。为了在一定程度上同步网络上多个机器之间的时间，通常使用NTP协议将本地设备的时间与专门的时间服务器对齐，这样做的一个直接结果是设备的本地时间可能会突然向前或者向后跳跃。

分布式事务既然是分布式的系统，自然也有NPC问题。因为没有涉及时间戳，带来的困扰主要是NP。

### 异常分类

一般情况下，一个TCC回滚