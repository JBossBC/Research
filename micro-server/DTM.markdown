# DTM

DTM是一款开源的分布式事务管理器,解决跨数据库、跨服务、跨语言栈更新数据的一致性问题。

通俗一点说,DTM提供跨服务事务能力，一组服务要么全部成功，要么全部回滚,避免只更新了一部分数据的一致性问题。



## DTM架构

整个DTM架构中，一共有三个角色

+ RM-资源管理器:RM是一个应用程序,负责管理全局事务中的本地事务,他通常会连接到一个数据库，负责相关数据的修改，提交，回滚，补偿等操作。
+ AP-应用程序:AP是一个应用服务，负责全局事务的编排，他会注册全局事务，注册子事务，**调用RM接口**。
+ TM-事务管理器:TM就是DTM服务，负责全局事务的管理，每个全局事务都注册到TM，每个事务分支也注册到TM。TM会协调所有的RM，将同一个全局事务的不同分支，全部提交或全部回滚。

### 跨语言特性

### 高可用

在这个架构中，TM不是单点，而是一个服务集群。集群由多个dtm实例进程构成，多个dtm实例访问同一个高可用数据库。

几乎所有的云厂商都会提供高可用的数据库，几乎所有要求业务高可用的公司内部，都会有高可用的数据库，因此将dtm对接到一个高可用数据库是毫无困难的。

在实际的生产部署中，DTM是多实例的，连接的共享存储是高可用的，因此不存在单点，从而提供了高可用的DTM服务。


### 多进程同时轮询

全局事务的运行过程中，可能出现各种网络错误，导致全局事务无法一次完成，需要定时重试。

DTM默认会在每个进程实例中，去轮询超时需要处理的全局任务。为了保证上面的高可用进程部署，一个超时任务不会被多个实例同时取出，dtm采用了类似乐观锁的机制，保证一个任务只会被一个dtm实例取出。

+ DB存储引擎： 采用update ... set owner=..., time=... where ... 这种方式，因为update的原子性，能够保证一条记录只被一个实例更新
+ Redis存储引擎： 采用lua脚本原子操作，保证一条记录只被一个实例取出

**当然极端情况下，还是有可能出现这个任务被两个进程取出，这个时候由于每个分支的结果是幂等的，所以最终不会影响结果的正确性。**



### 术语

DTM在分布式事务的理论与事件中，存在一些专业术语

+ 事务分支:我们把每个服务管理的全局事务组成部分，称为事务分支。
+ 分支操作:每个事务分支，在SAGA、XA、TCC等事务模式下，会有多个操作
+ 本地事务:转出事务分支中的正向操作，通常会开启一个事务，对余额进行扣减，我们将数据操作的这个事务，称为本地事务。
+ GID:全局事务ID，用于标记全局事务，必须唯一。该ID可以采用UUID生成，也可以采用业务上的ID。


### 接口协议

目前dtm只支持http和grpc协议，以及在这基础上的部分微服务协议。由于分布式事务涉及分布式协作，某些参与者可能出现暂时不可用或者返回500等异常情况是不可避免的。这些暂时不可用和500，与业务上的失败有非常大的区别


>接口错误与业务失败

> 例如前面的转出金额操作，如果遇见暂时不可用，或者500，此时不应当认为转账失败，而进行回滚。

> 有个dtm的用户，在未使用分布式事务的旧系统中，曾经遇到过这类事故，起因是开发人员在调用发红包后，因为调用超时，认为发红包失败，没有扣减用户的余额，但是当红包服务恢复正常后，发现红包已发出，这就导致了金额错误，造成了事故。

因此进行分布式事务开发时，切记 接口返回错误 不等于 业务失败



dtm系统中，调用分支事务的服务，有四种结果：

+ SUCCESS: 表示成功
+ FAILURE: 表示失败，这个失败是指确定的失败结果，不需要重试。例如子事务因转账余额不足而失败，dtm服务因为事务已完成不允许再次提交等
+ ONGOING: 表示未完成，还在正常进行中，此时dtm服务器需要采用固定间隔重试，而不是指数退避算法重试
+ **其他: 表示临时错误，采用指数退避算法重试，避免出现故障或者bug，导致大量重试，导致负载过高**


> ONGOING

> DTM 引入了一个特殊的结果 ONGOING，当 DTM 收到这个返回值时，认为这个子事务操作还在正常进行中，还未完成，需要进行重试。假如你需要预定旅游出行的机票，第三方可能需要1个小时才能够确认机票预定的结果，那么应用可以指定分布式事务的重试间隔时间，并在未获得确定结果时，返回 ONGOING，这样 DTM 会按照固定间隔时间重试。

对于HTTP和GRPC中，如何明确表示三种结果


1. HTTP

     SUCCESS: 状态码 200 StatusOK
     
     FAILURE: 状态码 409 StatusConflict

     ONGOING: 状态码 425 StatusTooEarly

2. gRPC

     SUCCESS: 状态码 OK

     FAILURE: 状态码 Aborted

     ONGOING: 状态码 FailedPrecondition


## SAGA


SAGA事务模式是DTM中最常用的模式，主要是因为SAGA模式简单易用，工作量少，并且能够解决绝大部分业务的需求。

> dtm的SAGA模式与Seata的SAGA在设计理念上是不一样的，整体使用难度大幅度下降，非常容易上手


SAGA最初出现在1987年Hector Garcaa-Molrna & Kenneth Salem发表的论文SAGAS里。其核心思想是将长事务拆分为多个短事务，由Saga事务协调器协调，如果每个短事务都成功提交完成，那么全局事务就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。



### 拆分为子事务

根据saga事务的原理，我们将整个全局事务，切分为一个个子事务，每个子事务包括:

+ 操作
+ 补偿操作


如果有正向操作失败，那么dtm会调用各分支的补偿操作，进行回滚，最后事务成功回滚。


> 补偿执行顺序

> dtm的SAGA事务在1.10.0以及之前，补偿操作是并发执行的，1.10.1之后，是根据用户指定的分支顺序，进行回滚的。

> 如果是普通SAGA，没有打开并发选项，那么SAGA事务的补偿分支是完全按照正向分支的方向顺序进行补偿的。

> 如果是并发SAGA，补偿分支也会并发执行，补偿分支的执行顺序与指定的正向分支顺序相反。假如并发SAGA指定A分支之后才能执行B，那么进行并发补偿时，DTM保证A的补偿操作在B的补偿操作之后执行。


### 如何做补偿

当SAGA对分支A进行失败补偿时，A的正向操作可能是1.已执行;2.未执行;3.甚至有可能处于执行中，最终执行结果是未知的。那么对A进行补偿时,要妥善处理好这三种情况，难度很大。


dtm提供了子事务屏障技术，自动处理上述三种情况，开发人员只需要编写好针对1的补偿操作情况即可。

**失败的分支是否需要补偿**

dtm常被闻到的一个问题就是，TransIn返回失败，那么这个时候是否还需要调用TransIn的补偿操作?DTM的做法就是,统一进行一次调用，这种的设计考虑点如下:

+ XA,TCC等事务模式是必须要的,SAGA为了保持简单和统一,设计为总是调用补偿。
+ DTM支持单服务多数据源，可能出现数据源1成功，数据源2失败，这种情况下，需要确保补偿被调用，数据源1的补偿被执行
+ DTM提供的子事务屏障，自动处理了补偿操作中的各种情况，用户只需要执行与正向操作完全相反的补偿即可


### 异常

在事务领域，异常是重点考虑的问题。当我们面对分布式事务，那么分布式中的异常出现更加频繁，对于异常的设计和处理，更是重中之重。


我们将异常分为以下几类:

+ 偶发失败: 在微服务领域，由于网络抖动，机器宕机，进程Crash会导致微小比例的请求失败。这类问题的解决方案是重试，第二次进行重试，就能够成功，因此微服务框架或者网关类产品，都会支持重试，DTM的设计对重试非常友好，应当支持幂等的各个接口都已支持幂等，不会发生因为重试导致事务bug的情况。
+ 故障宕机:大量公司内部都有复杂的多项业务，这些业务中偶尔有一两个非核心业务故障也是常态。DTM也考虑了这样的情况，在重试方面做了指数退避算法，如果遇见了故障宕机情况，那么指数退避可以避免大量请求不断发往故障应用，避免雪崩。
+ 网络乱序:分布式系统中，网络延迟是难以避免的，所以会发生一些乱序的情况。


业务上的失败与异常是需要严格区分的。分布式事务中，有很多模式的某些阶段，要求最终成功，例如dtm的补偿操作，是要求最终成功的，只要还没成功，就会不断进行重试，直到成功。


### 高级用法



+ 优化重试策略: dtm默认情况下，重试策略是指数退避算法，可以避免出现故障时，过多的重试导致负载过高。但是在某些场景下，应采取固定间隔重试，这样才能及时通知到用户。(saga.RetryInterval参数)

		saga := dtmcli.NewSaga(DtmServer, gid).
			Add(Busi+"/BookTicket", Busi+"/BookTicketRevert", bookTicketInfo1).
			Add(Busi+"/BookHotel", Busi+"/BookHotelRevert", bookHotelInfo2).
			Add(Busi+"/BookTicket", Busi+"/BookTicketRevert", bookTicketBackInfo3)

        saga.EnableConcurrent()

        saga.RetryInterval = 60
        saga.Submit()

        func bookTicket() string {
	          order := loadOrder()
	          if order == nil { // 尚未下单，进行第三方下单操作
		         order = submitTicketOrder()
		         order.save()
	}
	          order.Query() // 查询第三方订单状态
	          return order.Status // 成功-SUCCESS 失败-FAILURE 进行中-ONGOING
}

+ 解决无法回滚的操作:对于不可回滚的操作,DTM的设计建议是，不可回滚的操作在业务上也不允许返回失败。可以这么思考，如果发货的操作返回了失败，那么这个失败的含义是不够清晰的，调用方不知道这个失败是修改了部分数据的失败，还是修改数据前的业务校验失败，因为这个操作不可回滚，所以调用方收到这个失败，是不知道如何正确处理这个错误。另外当你的一个全局事务中，如果出现了两个既不可回滚的又可能返回失败的操作，那么到了实际运行的时候，一个执行成功，一个执行失败，此时执行成功的那个事务就无法回滚，那么这个事务的一致性就不可能保证了(AddBranchOrder)

		saga := dtmcli.NewSaga(DtmServer, shortuuid.New()).
			Add(Busi+"/CanRollback1", Busi+"/CanRollback1Revert", req).
			Add(Busi+"/CanRollback2", Busi+"/CanRollback2Revert", req).
			Add(Busi+"/UnRollback1", "", req).
			Add(Busi+"/UnRollback2", "", req).
			EnableConcurrent().
			AddBranchOrder(2, []int{0, 1}). // 指定step 2，需要在0，1完成后执行
			AddBranchOrder(3, []int{0, 1}) // 指定step 3，需要在0，1完成后执行


+ 其他分支的结果作为输入

前面的设计环节讲了为什么dtm没有支持这样的需求，那么如果极少数的实际业务有这样的需求怎么处理？例如B分支需要A分支的执行结果

dtm的建议做法是，在ServiceA再提供一个接口，让B可以获取到相关的数据。这种方案虽然效率稍低，但是易理解已维护，开发工作量也不会太大。

PS：有个小细节请注意，尽量在你的事务外部进行网络请求，避免事务时间跨度变长，导致并发问题。

如果您需要其他分支的结果作为输入，也可以考虑一下dtm里面的 TCC 模式，该模式有不同的适用场景，但是提供了非常便捷的获取其他分支结果的接口


## 二阶段消息(不是二阶段提交)

二阶段消息是dtm首创的事务模式，用于替换本地事务表和事务消息这两种现有方案。它能够保证本地事务的提交和全局事务提交是原子的，是和解决不需要回滚的分布式事务场景。











## 异常与子事务屏障

分布式事务之所以难，主要是因为分布式系统中各个节点都可能发生各种非预期的情况。

### NPC的挑战

分布式系统的最大敌人就是NPC了，在这里它是Network Delay,Process Pause,Clock Drift的首字母缩写

+ Network Delay,网络延迟。虽然网络在多数情况下工作的还可以，虽然TCP保证传输顺序和不会丢失，但它无法消除网络延迟问题。
+ Process Pause，进程暂停。有很多种原因可以导致进程暂停:比如编程语言中的GC会STW,以及云服务器迁移。
+ Clock Drift,时钟漂移。现实生活中我们通常认为时间是平稳流逝，单调递增的，但在计算机中不是。计算机使用时钟硬件记时间，通常是石英钟，记时精度有限，同时受机器温度影响。为了在一定程度上同步网络上多个机器之间的时间，通常使用NTP协议将本地设备的时间与专门的时间服务器对齐，这样做的一个直接结果是设备的本地时间可能会突然向前或者向后跳跃。

分布式事务既然是分布式的系统，自然也有NPC问题。因为没有涉及时间戳，带来的困扰主要是NP。

### 异常分类

一般情况下，一个TCC回滚