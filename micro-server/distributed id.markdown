# distributed id

在复杂的分布式系统中，往往需要对大量数据和消息进行唯一标识

在金融、电商、支付等产品的系统中，数据日渐增长，对数据分库分表后需要有一个唯一ID来标识一条数据或消息，数据库的自增ID显然不能满足要求，此时一个能够生成全局唯一ID的系统是非常必要的。

## 分布式ID的特点

1. 全局唯一性:不能出现重复的ID号，既然是唯一标识，这是最基本的要求
2. 趋势递增:在mysql innodb引擎中使用的是聚集索引，多数RDBMS使用b-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入的性能
3. 单调递增:保证下一个ID一定大于上一个ID,例如事务版本号、IM增量消息、排序等特殊需求
4. 信息安全:	如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可;如果是订单号就更危险了，竞争对手可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则或者不规则

同时除了对ID号码自身的要求，业务还对ID号生成系统的可用性要求极高。因为如果ID生成系统瘫痪，就会带来一场灾难。所以一个ID生成系统应该做到如下几点:

1. 平均延迟和TP999延迟都要尽量低
2. 可用性5个9
3. 高qps

## 分布式ID生成方案

+ zookeeper生成唯一ID
+ redis生成唯一ID
+ UUID唯一ID
+ snowflake(雪花算法)
+ 数据库生成唯一ID

## UUID

UUID的标准形式包含32个19进制数字，以连字号分五段，形式为8-4-4-4-12的32个字符，示例：550e8400-e29b-41d4-a716-446655440000，到目前为止业界一共有5种方式生成UUID，详情见IETF发布的UUID规范 A Universally Unique IDentifier (UUID) URN Namespace。

### 优点

+ 性能非常高,本地生成，没有网络消耗

### 缺点

+ 不易存储:UUID太长,通常以36长度的字符串标识，很多场景不适合
+ 信息不安全:基于MAC地址生成UUID的算法可能会造成MAC地址泄露
+ ID作为主键时在特定环境下会存在一些问题。

## 数据库生成ID

利用给字段设置auto_increment_increment和auto_increment_offset离保证ID自增，每次业务使用下列sql读写mysql得到ID号

### 优点

+ 简单，成本小，有DBA专业维护
+ ID号单调自增，可以实现一些对ID有特殊要求的业务

### 缺点

+ 强依赖DB，当DB异常整个系统不可用，属于致命问题，主从复制可以增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号
+ ID发号的性能瓶颈限制在单台mysql的读写性能。

## redis生成id

当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。

这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。

比较适合使用Redis来生成每天从0开始的流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。

### 优点:

+ 不依赖数据库，灵活方便，且性能优于数据库
+ 数字ID天然排序，对分页或者需要排序的结果非常有帮助

### 缺点:

1）如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。

2）需要编码和配置的工作量比较大。

## 利用zookeeper生成唯一ID

zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号

很少有使用zookeeper来生成唯一ID。主要是由于需要依赖zookeeper,并且是多步调用API，如果在竞争较大的情况下，需要考虑使用分布式锁。因此，性能在高并发的分布式环境下，很不堪理想

## snowflake雪花算法生成ID

这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等，比如在snowflake中的64-bit分别表示如下图（图片来自网络）所示：

+ 第一位不用
+ 41位毫秒级时间
+ 10位工作机器id
+ 12位序列号

41-bit的时间可以表示69年的时间，10bit的机器可以表示1024台机器。如果我们对IDC划分有需求，还可以将10bit分5bit给IDC,分5bit给工作机器，这样就可以表示32个IDC，每个IDC下可以有32台机器，可以根据自身需求定义。12个自增序列号可以表示2^12个ID，理论上snowflake方案的qps约为409.6w/s，这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的

### 优点

+ 毫秒数在高位，自增序列在地位，整个ID都是趋势递增的
+ 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成id的性能也非常高
+ 可以根据自身业务特性分配bit位，非常灵活。

### 缺点

+ 强依赖机器时钟，可能会在时钟漂移的过程中导致发号重复或者服务会处于不可用状态。