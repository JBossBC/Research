# IPFS


IPFS协议栈分为七层,分别是身份层，网络层，路由层，交换层，对象层文件层，命名层

+ 身份层: S/Kademlia算法增加创建新身份的成本。对等节点身份信息生成和验证
+ 网络层: 支持任意传输层协议，overlay网络 webRTC& ICE NET & NAT穿透
+ 路由层: 分布式哈希表(DHT)定位对等节点和存储对象所需要的信息
+ 交换层: BitTorrent & Bitswap 保证节点网络稳定、激励交换数据行为
+ 对象层: Merkle-DAG &IPLD 内容可寻址的不可篡改，去冗余的对象链接
+ 文件层: 类似git版本控制的文件系统
+ 命名层: 具有SFS(Self-Certified Filesystem) & IPNS DNS TXT 解析，Proquint可发音域名绑定


## 身份层

在IPFS网络中，所有的节点都通过唯一的NodeID进行标识,与Bitcoin的地址类似，NodeId是一个公钥的哈希，为了增加攻击者的成本,IPFS使用S/kademlia中的算法增加创建新身份的成本。

每一个节点在IPFS代码中都由Node结构体来标识，其中只包含NodeId及一组公私钥对。

身份系统的主要功能是标识IPFS网络中的节点。类似"用户"信息的生成。在节点首次创建连接时，节点之间首先交换公钥，并且进行身份信息验证，例如:检查hash的值是否等于nodeId。如果校验不通过，则用户信息不匹配，节点立即终止连接。

IPFS使用的哈希算法比较灵活，允许用户根据使用自定义。默认以Multihash格式存储。

## 网络层

IPFS节点与网络中其他成千上万个节点进行通信时，可以兼容多种底层传输协议。

+ 传输: IPFS兼容现有的著有传输协议，其中有最适合浏览器端使用的webRTC DataChannels，也有低延时uTP(LEDBAT)等传输协议。
+ 可靠性:使用uTP和sctP来保证，这两种协议可以动态调整网络状态。
+ 可连接性:使用ICE等NAT穿透技术来实现广域网的可连接性
+ 完整性:使用哈希校验验证数据完整性，IPFS网络中所有数据块都具有唯一的哈希值。
+ 可验证性:使用数据发送者的公钥及HMAC消息认证码来检查消息的真实性。


IPFS 几乎可以使用任意网络进行节点之间的通信，没有完全依赖于IP 协议。IPFS 通过 multiaddr 的格式来表示目标地址和其使用的协议，以此来兼容和扩展未来可能出现的其他网络协议。


IPFS的网络通信模式是遵循覆盖网络(Overlay Network)的理念设计的。覆盖网络的模型如图 所示，是一种网络架构上叠加的虚拟化技术模式，它建立在已有网络上的虚拟网，由逻辑节点和逻辑链路构成。图中多个容器在跨主机通信的时候，使用 Overlay Network 网络模式。首先虚拟出类似服务网关的IP 地址，例如 10.0.9.3，然后把数据包转发到 Host(主机)物理服务器地址最终通过路由和交换到达另一个 Host 服务器的IP 地址。


## 路由层

IPFS节点需要一个路由系统，这个路由系统可以用于查找同伴节点的网络地址;专门用于服务特定对象的对等节点

IPFS路由层数据结构使用基于S/Kademlia和Coral技术的DSHT.在设置数据对象大小和使用模式方面,IPFS参考了COral和Mainline设计思想，因此，IPFS的DHT结构会根据所存储数据的大小进行区分:小的值(小于等于1KB)直接存储在DHT上:更大的值，DHT只存储值索引，这个索引就是一个节点的NOdeId,该节点可以提供对该类型值的具体服务。

IPFS的路由实现了3 种基本功能: 内容路由、节点路由及数据存储。这种实现方式降低了系统的耦合度，开发者可以根据自身业务需求自定义路由，同时不影响其他功能。

## 交换层

bitswap主要功能是利用信用机制在节点之间进行数据交换。受到bitTorrent技术的启发，每个节点1在下载的同时不断向其他节点上传已下载的数据。和 BitTorrent 协议不同的是,BitSwap 不局限于一个种子文件中的数据块。BitSwap 协议中存在一个数据交换市场，这个市场包括各个节点想要获取的所有块数据，这些块数据可能来自文件系统中完全不相关的文件，同时这个市场是由 IPFS 网络中所有节点组成的。

bitswap协议主要负责两件事情:向其他节点请求需要的数据块列表，以及为其他节点提供已有的数据块列表。


当我们需要向其他节点请求数据块或者为其他节点提供数据块时，都会发送 BitSwap Message 消息，其中主要包含了两部分内容: 想要的数据块列表(want_list)及对应数据块。消息使用 Protobuf 进行编码。


在bitswap系统中，有两个非常重要的模块--需求管理器和决策引擎:前者会在节点请求数据块是在本地返回相应的结果或者发出合适的请求;而后者决定如何为其他节点分配资源，当节点接收到包含want_list的消息时，消息会被转发至决策引擎，引擎会根据该节点的bitswap账单决定如何处理请求。

一次BitSwap数据交换的全过程及节点的生命周期中，节点一般要经历4个状态。

+ 状态开发：对等节点间开放待发送BitSwap账单状态，直到建立连接。
+ 数据发送:节点间发送want_list和数据块
+ 连接关闭:节点发送完数据后断开连接
+ 节点忽略:节点因为超时、自定义、信用分过低等因素被忽略。


### Peer.open

当节点建立连接时，发送方节点初始化BitSwap信用账单，保存一份对等方的账单或者创建一个新的被清零的信用账单，这取决于节点信用账单一致性之后，发送方节点将发送一个携带账单的open信息通知接收方节点，接收方节点收到一个open信息之后，选择是否接收此连接。

如果接收方根据本地的信用账单数据，发现发送方是一个不可信的节点例如传输超时、信用分较低、债务率较高等，则接收方会通过ignore_cooldown忽略这个请求，并且断开连接，目的是防范作弊行为。

如果连接成功，接收方将用本地信用账单来初始化一个Peer对象，并更新last_seen时间戳。然后，它会将接收到的账单与自己的账单比较。如果两个信用账单完全一直，那么这个连接就被开放;如果账单不完全一致，那么此节点会创建一个新的被清零的信用账单，并发送同步此信用账单，以此保证发送方节点和接收方节点的账单一致。


### Peer.send_want_list(WantList)

当连接已经处于开放状态时，发送方节点将会把want_list广播给所有连接的接收方节点。与此同时，接收方节点在收到一个want_list后，会检查自身是否有接收方想要的数据块。如果有，会使用bitswap策略来传输这些数据块。

### Peer.send_block(Block)

发送块的方法逻辑很简单，默认发送方节点只传输数据块，接收到所有数据后，接收方节点计算Multihash以验证它是否与预期的匹配，然后返回确定。在完成块传输后，接收方节点将数据块信息从need_list移到have_list,并且接收方和发送方都同步更新他们的账单列表。如果传输验证失败，则发送方可能发生故障或存在故意攻击接收方的行为，接收方可以拒绝进一步的交易。

### Peer.close(Bool)

对等连接应该在两种情况下关闭:

+ silent_wait 已超时，但未收到来自对方的任何消息(默认BitSwap 使用30秒)，节点发出 Peer.close (false)。
+ 节点正在退出，BitSwap 正在关闭，在这种情况下，节点发出Peer.close(true)。


### bitswap信用体系

bitswap协议能够激励节点去分享数据，即使这个节点暂时没有数据需求。IPFS根据节点之间的数据收发建立了一个信用体系:有借有还，再借不难。

+ 给其他节点发送数据可以增加信用值
+ 从其他节点接收数据将降低信用值。


如果一个节点只接收数据而不分享数据，信用值就会降得很低而被其他节点忽略掉。简单来说，其实就是你乐于分享数据，其他节点也乐于发送数据给你;如果你不愿意分享，那么其他节点也不愿意给你数据。

根据上面的信用体系，bitswap可以采取不同的策略来实现，每一种策略都会对系统的整体性产生不同的影响。策略的目标是:

+ 节点数据交换的整体性能和效率力求最高
+ 阻止空载节点"吃白食"现象，即不能够只下载数据不上传数据
+ 可以有效地防止一些攻击行为
+ 对信任节点建立宽松机制


## 对象层

IPFS使用Merkle DAG技术构建了一个有向无环图数据结构，用来存储对象数据。Merkle DAG 为 IPFS 提供了很多有用的属性，包括:

+ 内容可寻址:所有内容由多重哈希校验并唯一标识。
+ 防止篡改:所有内容都通过哈希验证，如果数据被篡改或损坏，在 IPFS网络中将会被检测到。
+ 重复数据删除:保存完全相同内容的所有对象都是相同的，并且只存储次。这对于索引对象特别有用。


### 本地对象


IPFS 客户端需要一个本地存储器，一个外部系统可以为 IPFS 管理的对象存储及检索本地原始数据。存储器的类型根据节点使用案例而异。在大多数情况下，这个存储器只是硬盘空间的一部分(不是被本地的 leveldb 来管理，就是直接被 IPFS 客户端管理)，在其他情况下，例如非持久性缓存，存储器就是 RAM的一部分。




