# Cache Mode

享元模式是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多的对象(实现过程有点像缓存,在构建享元的过程中，实际上就是事先搜索已经创建的对象，如果想要创建的对象已经被创建，那么直接拿来使用)

## Question

加入你希望在长时间工作后放松一下，所以简单地开发了一款游戏:玩家们在地图上移动并相互射击。你决定实现一个真实的粒子系统，并将其作为游戏的特色。大量的子弹、导弹和爆炸弹片会在整个地图上穿行，为玩家提供紧张刺激的游戏体验。

开发完成后，你推送提交了最新版本的程序，并在编译游戏后将其发送给了一个朋友进行测试。尽管该游戏在你的电脑上完美运行，但是你的朋友却无法长时间进行游戏:游戏总是会在他的电脑上运行几分钟后崩溃。在研究几个小时的调试消息记录后，你发现导致游戏崩溃的原因是内存容量不足。

真正的问题与粒子系统有关。每个粒子都由包含完整数据的独立对象来表示。当玩家在游戏中鏖战进入高潮后的某个时刻，游戏将无法在剩余内存中载入新的粒子，于是程序就崩溃了。

## 解决方案

仔细观察粒子类，你可能会注意到颜色和精灵图这两个成员变量所消耗的内存要比其他变量多得多。更糟糕的是,对于所有的粒子来说，这两个成员变量所存储的数据几乎完全一样。

每个粒子的另一些状态则是不同的，因为这些成员变量的数值会不断变化。这些数据代表粒子在存续期间不断变化的场景，但每个粒子的颜色和精灵图则会保持不变。

对象的常量数据通常被称为内在状态，其位于对象中，其他对象只能读取但不能修改其数值。而对象的其他状态常常能被其他对象"从外部"改变，因此被称为外在状态。

享元模式建议不在对象中存储外在状态，而是将其传递给依赖于它的一个特殊的方法。程序只在对象中保存内在状态，以方便在不同情景下重用。这些对象的区别仅在于其内在状态(与外在状态相比，内在状态的变体要少很多)，因此你所需的对象数量会大大削减。

### 外在状态存储

在大部分情况中，外在状态会被移动到容器对象中，也就是**我们应用享元模式前的聚合对象中**

更优雅的解决方案是创建独立的情景类来存储外在状态和对享元对象的引用。在该方法中，容器类只需包含一个数组。


### 享元与不可变性

**由于享元对象可在不同的情景中使用，你必须确保其状态不能被修改。享元类的状态只能由构造函数的参数进行一次性初始化，他不能对其他对象公开其设置器或公有成员变量。**

### 享元工厂

**为了能更方便地访问各种享元，你可以创建一个工厂方法来管理已有的享元对象的缓存池。工厂方法从客户端处接收目标享元对象的内在状态作为参数，如果它能在缓存池中找到所需享元，则将其返回给客户端;如果没有找到，他就会新建一个享元，并将其添加到缓存池中。**


## 享元模式的优缺点

+ 优点

       + 如果程序中有很多相似对象，能够节约大量内存

+ 缺点

      + 可能需要牺牲执行速度来换取内存，因为他人每次调用享元方法时都需要重新计算部分场景数据
      + 代码会变得复杂


## 与其他模式的关系

+ 你可以使用享元模式实现组合模式树的共享叶节点以节省内存。????????
+ 享元展示了如何生成大量的小型对象，外观模式则展示了如何用一个对象来代表整个子系统。