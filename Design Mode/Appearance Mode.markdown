# Appearance Mode


外观模式是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口


## Question

假设你必须在代码中使用某个复杂的库或框架中的众多对象。正常情况下，你需要复杂所有对象的初始化工作、管理其依赖关系并按照正确的顺序执行方法等

最终，程序中类的业务逻辑与第三方类的实现细节紧密耦合，使得理解和维护代码的工作很难进行。


## 解决方案

外观类为包含许多活动部件的复杂子系统提供一个简单的接口。与直接调用子系统相比，外观模式提供的功能可能比较有限，但它却包含了客户端真正关心的功能。

如果你的程序需要与包含几十种功能的复杂库整合，但只需使用其中非常少的功能，那么使用外观模式会非常方便 



## 实现方式

1. 考虑能否在现有子系统的基础上提供一个更简单的接口。如果该接口能让客户端代码独立于众多子系统类，那么你的方向就是正确的
2. 在一个新的外观类种声明并实现该接口。外观应将客户端代码的调用重定向到子系统中的相应对象处。如果客户端代码没有对子系统进行初始化，也没有对其后续生命周期进行管理，那么外观必须完成此类工作。
3. 如果要充分发挥这一模式的优势，你必须确保所有客户端代码仅通过外观与子系统进行交互。此后客户端代码将不会受到任何由子系统代码修改而造成的影响，比如子系统升级后，你只需修改外观中的代码即可。
4. 如果外观变得过于臃肿，你可以考虑将其部分行为抽取为一个新的专用外观类。


## 外观模式的优缺点

+ 优点

     + 你可以让自己的代码独立于复杂子系统

+ 缺点
     
     + 外观可能成为与程序中所有类都耦合的上帝对象


## 与其他模式的关系

+ 外观模式为现有对象定义一个新接口，适配器模式则会试图运用已有的接口。适配器通常只封装一个对象，外观通常会作用于整个对象子系统上。
+ 当只需对客户端代码隐藏子系统创建对象的方式时，你可以使用抽象工厂模式来代替外观
+ 享元模式展示了如何生成大量的小型对象，外观则表示了如何用一个对象来代表整个子系统。
+ 外观和中介者的职责类似:它们都尝试在大量紧密耦合的类中组织起合作。

      + **外观为子系统的所有对象定义了一个简单的接口,但是它不提供任何新功能**。子系统本身不会意识到外观的存在。子系统中的对象可以直接进行交流
      + 中介者将系统中组件的沟通行为中心化。各组件只知道中介者对象，无法直接相互交流。

+ 外观类通常可以转换为单例模式类，因为在大部分情况下有一个外观对象就足够了
+ 外观和代理模式的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。代理与其服务对象遵循同一接口，使得自己和服务对象可以互换，在这一点上它与外观不同
