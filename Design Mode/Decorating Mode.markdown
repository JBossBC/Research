# Decorating Mode

装饰模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。


## 需求情景

假设你正在开发一个提供通知功能的库，其他程序可以使用它向用户发送关于重要事件的通知。

库的最初版本是基于通知器Notifier类，其中只有很少的几个成员变量，一个构造函数和一个send方法。该方法可以接收来自客户端得到消息参数，并将消息发送给一系列的邮箱，邮箱列表则是通过构造函数传递给通知器的。作为客户端的第三方程序仅会创建和配置通知器对象一次，然后在有重要事件发生时对其进行调用。

此后某个时刻，你会发现库的用户希望使用除邮件通知之外的功能。许多用户则会希望接收关于紧急事件的手机短信，还有些用户希望在微信上接收消息，而公司用户则希望在QQ上接收消息。

一般的实现方法，在接口定义上扩展新的方法,然后再扩展新的子类，加入额外的通知方法。。现在客户端要对所需通知形式的对应类进行初始化，然后使用该类发送后续所有的通知消息。

但是新的业务问题就会出现:"为什么不同时使用多种通知形式呢?如果房子着火了，你大概会想在所有渠道中都收到相同的消息吧"

可以尝试用创建一个特殊子类来将多种通知方法组合在一起解决问题。但这种方式会使得代码量迅速膨胀


## conclusion
当你需要更改一个对象的行为时,第一个跳入脑海的想法就是扩展它所属的类。但是，你不能忽视继承可能引发的几个严重问题。

+ 继承是静态的。你无法在运行时更改已有对象的行为，只能使用不同子类创建的对象来替代当前的整个对象
+ 子类只能有一个父类。大部分编程语言都不允许一个类同时继承多个类的行为

其中一种方法是用聚合和组合，而不是继承。两者的工作方式几乎一模一样:**当一个对象包含指向另一个对象的引用，并将部分工作委派给引用对象;继承中的对象则继承了父类的行为，它们自己能够完成这些工作**。

你可以使用这个新方法来轻松替换各种连接的小帮手对象，从而能在运行时改变容器的行为。一个对象可以使用多个类的行为，包含多个指向其他对象的引用，并将各种工作委派给引用对象。聚合是多种设计模式背后的关键原则

封装器是装饰模式的别称。封装器是一个能与其他目标对象连接的对象。封装器包含了与目标对象相同的一系列方法,它会将所有接收到的请求委派给目标对象。但是，封装器可以在将请求委派给目标前后对其进行处理,所以可能会改变最终结果

