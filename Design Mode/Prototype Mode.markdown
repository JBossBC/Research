# Prototype Mode

原型模式是一种创造型设计模式,使你能够复制已有对象，而又无需使代码依赖它们所属的类

## Question

如果你有一个对象，并希望生成与其完全相同的一个复制品,你该如何实现呢？首先,你必须创建一个属于相同类的对象。然后,你必须遍历原始对象的所有成员变量,并将成员变量值复制到新对象中。

但有个小问题，**并非所有对象都能通过这种方式进行复制，因为有些对象可能拥有私有成员变量，它们在对象本身之外是不可见的。直接复制还有另一个问题，因为你必须知道所属的类才能创建复制品,所以代码必须依赖该类。即使你可以接收额外的依赖性，还有另一个问题:有时你只知道对象所实现的接口,而不知道其所属的具体类。**

## 解决方案

原型模式将克隆过程委派给被克隆的实际对象。模式为所有支持克隆的对象声明了一个通用接口，该接口让你能够克隆对象，同时又无需将代码和对象所属类耦合。通常情况下，这样的接口中仅包含一个克隆方法。

所有的类对克隆方法的实现都非常相似。该方法会创建一个当前类的对象，然后将原始对象的所有的成员变量值复制到新建的类中。你甚至可以复制私有成员变量，**因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。**

支持克隆的对象即为原型。当你的对象有几十个成员变量和几百种类型时,对其进行克隆甚至可以代替子类的构造。

运作方式如下:创建一系列不同类型的对象并不同的方式对其进行配置。如果所属对象与预先配置的对象相同，那么你只需克隆原型即可，无需新建一个对象。

## 应用场景

+ 如果你需要复制一些对象，同时又希望代码**独立于这些对象所属的具体类,可以使用原型模式**

        这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。即使不考虑代码耦合的情况,你的代码也不能依赖这些对象所属的具体类,因为你不知道它们的具体信息。
         
        原型模式为客户端代码提供一个通用接口，客户端代码可通过这一接口与所有实现了克隆的对象进行交互,它也使得客户端代码与其所克隆的对象具体类独立开来。

+ 如果子类的区别仅在于其对象的初始化方式,那么你可以使用该模式来减少子类的数量。别人创建这些子类的目的可能是为了创建特定类型的对象

        在原型模式中,你可以使用一系列预生成的、各种类型的对象作为原型。
 
        客户端不必根据需求对子类进行实例化,只需找到合适的原型并对其进行克隆即可。


## 总结

总的来说,为什么使用原型模式?首先原型模式最终的目的是克隆现有的对象，并且在不依附该对象的实现类的情况下。如何实现？通过二进制流的方式，利用原有的对象创建克隆对象。为什么能够提高创建对象的效率?首先,此设计模式我认为主要的应用场景的前提是通过类创建对象的开销过大，体现在初始化方法太过庞大，对于golang的话其实很少有原型模式的落地场景，因为首先考虑到原型模式的有点在于不依附实现类的情况下能够减少创建对象的开销，但是原型设计本身会违反"开闭原则",同时对于golang这门语言来说,原型设计可能不太符合程序设计。 

